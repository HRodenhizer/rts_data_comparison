---
output:
  html_document: default
  pdf_document: default
---

# RTS Model V2 Performance Analysis

## TODO:

-   Possible to remove extra influence of multiple RTS within one tile?
-   Figure out why my IoU scores don't quite match Yili's - Possible that this is being calculated on a different set of polygons? Still not sure if I need to remove classes that are missing from predictions.
-   Decide whether to use best RTS threshold or 0.5
-   Figure out some sort of explanation method to figure out which cells were most important to predictions? Does this even make sense in a context where we get probabilities out of the model rather than a label?
-   Run some sort of analysis of probabilities and input data layer values?

## Set-Up
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

## Load Libraries

```{r, include = FALSE}
library(reticulate)
library(terra)
library(sf)
library(spData)
library(leaflet)
library(viridis)
library(googledrive)
library(jsonlite)
library(smoothr)
library(tidymodels)
library(emmeans)
library(nlstools)
library(Ryacas)
library(ggnewscale)
library(egg)
library(ggsignif)
library(tidyverse)
```

```{python, include = FALSE}
import json
from keras_unet_collection import models, utils
import shap
from matplotlib import pyplot as plt
import numpy as np
```

## Prep Google Drive Authentication

```{r, include = FALSE}
drive_auth(email = 'hrodenhizer@woodwellclimate.org')
```


## Define Functions

### assign_conf_stars

```{r, include = FALSE}
assign_conf_stars <- function(x) {
  case_when(x <= 0.0001 ~ '****',
            x <= 0.001 ~ '***',
            x <= 0.01 ~ '**',
            x <= 0.05 ~ '*',
            x <= 0.1 ~ '.',
            x > 0.1 ~ '')
}
  
```

### avg_precision

```{r, include = FALSE}
avg_precision <- function(recall, precision) {
  
  ap <- sum((recall[1:length(recall) - 1] - recall[2:length(recall)])*precision[1:length(precision) - 1], na.rm = TRUE)
  return(ap)
  
}
```

### bbox

```{r, include = FALSE}
bbox <- function(prediction) {
  bbox <- prediction[['prediction']] %>%
    ext() %>%
    st_bbox(crs = crs(prediction)) %>%
    st_as_sfc() %>%
    st_as_sf() %>%
    mutate(id = get_rast_id(prediction)) %>%
    rename(bbox_geometry = x)
  
  return(bbox)
  
}
```

### calc_rts_threshold

```{r}
calc_rts_threshold <- function(prediction, thresholds) {
  
  mean_iou <- c()
  
  for (threshold in thresholds) {
    
    # classify the prediction
    prediction[['pred_class']] <- classify(
      prediction[['prediction']],
      matrix(c(0, threshold, 0,
               threshold, 1, 1),
             byrow = TRUE,
             ncol = 3),
      right = FALSE
    )
    
    # calculate ground truth classes
    prediction[['zones']] <- prediction[['pred_class']] + prediction[['validation']]
    prediction[['area']] <- cellSize(prediction[['zones']])
    
    # calculate zonal stats
    areas <- zonal(prediction[['area']],
                   prediction[['zones']],
                   fun = 'sum')
    
    # calculate mean IoU
    rts_iou <- ifelse(is.na(areas$area[3]),
                      0,
                      areas$area[3]/(areas$area[3] + areas$area[2]))
    bg_iou <- areas$area[1]/(areas$area[1] + areas$area[2])
    mean_iou <- c(mean_iou, mean(c(rts_iou, bg_iou)))
    
    
  }
  
  output <- tibble(
    id = get_rast_id(prediction),
    threshold = thresholds,
    mean_iou = mean_iou
  )
  
  return(output)
  
}
```

### eval_expression

```{r, include = FALSE}
eval_expression <- function(expression, x) {
  return(eval(expression))
}
```

### filter_input_data

```{r}
filter_input_data <- function(input_list, ids) {
  input_filtered <- list()
  input_ids <- c()
  idx <- 0
  for (input in input_list) {
    input_id <- get_rast_id(input)
    if (input_id %in% ids) {
      idx <- idx + 1
      input_ids <- c(input_ids, input_id)
      input_filtered[[idx]] <- input
    }
    
  }
  
  input_ordered <- list()
  idx <- 0
  for (id in ids) {
    
    idx <- idx + 1
    input_ordered[[idx]] <- input_filtered[[which(input_ids == id)]]
  }
  
  return(input_ordered)
  
}
```

### get_rast_id

```{r, include = FALSE}
get_rast_id <- function(rast) {
  id <- first(str_split(last(str_split(sources(rast), 
                                       '/')[[1]]), 
                        '\\.')[[1]])
  return(id)
}
```

### googledrive_download

```{r, include = FALSE}
googledrive_download <- function(name, id, drive_resource, directory) {
  current <- as_dribble(id)
  make_my_dir(directory)
  filepath = paste0(directory, '/', name)
  
  if (!file.exists(filepath)) {
    print(filepath)
    dl <- drive_download(
      current,
      path = filepath)
  }

}
```

### input_as_df

```{r, include = FALSE}
input_as_df <- function(input, pred) {
  
  input[['prediction']] <- pred[['prediction']]
  
  # unify layer names
  names(input) <- c('r', 'g', 'b', 'ndvi', 'elev', 'sr', 'nir', 'ndwi', 'rts_class', 'prediction')
  
  # get polygon ID
  current_id <- get_rast_id(input)
  
  # add stretched rgb
  input_stretch <- stretch(subset(input, 1:3),
                          minv = 0,
                          maxv = 1,
                          minq = 0.01,
                          maxq = 1)
  names(input_stretch) <- c('r_stretch', 'g_stretch', 'b_stretch')
  
  input <- c(input, input_stretch)
  
  # convert to dataframe
  df <- input %>%
    as.data.frame(xy = TRUE) %>%
    mutate(id = current_id,
           rts_class = factor(
             case_when(is.na(rts_class) ~ 'bg',
                       rts_class == 1 ~ 'rts'),
             levels = c('rts', 'bg')
           ),
           r = r/max(r, na.rm = TRUE),
           g = g/max(g, na.rm = TRUE),
           b = b/max(b, na.rm = TRUE),
           lum = 0.299*r + 0.587*g + 0.114*b, # lum equation from: https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color
           nir = nir/max(nir, na.rm = TRUE)) %>%
    filter(!(is.na(r_stretch) | is.na(g_stretch) | is.na(b_stretch))) %>%
    mutate(
      color_hex = factor(rgb(r_stretch, g_stretch, b_stretch, maxColorValue = 1))
    )
  return(df)
  
}
```

### import_pred

```{r}
import_pred <- function(filepath) {
  raster <- rast(filepath)
  names(raster) <- c('prediction', 'validation')
  return(raster)
}
```

### lm_contrasts

```{r}
lm_contrasts <- function(model) {
  contrasts <- as_tibble(emmeans(model$fit,
                                 pairwise ~ pq_ci_size,
                                 adjust = 'tukey')$contrasts) %>%
    mutate(star_label = assign_conf_stars(p.value)) %>%
    select(contrast, estimate, se = SE, p_value = p.value, star_label)
}
```

### lm_summary

```{r}
lm_summary <- function(model) {
  model_output <- tidy(model) %>%
    rename_with(~ str_replace_all(., '\\.', '_'))
  return(model_output)
}
```

### make_my_dir

```{r, include = FALSE}
make_my_dir <- function(output_dir) {

  if (!dir.exists(output_dir)){
    dir.create(output_dir, recursive = TRUE)
  }
  
}
```

### my_lm

```{r}
my_lm <- function(df) {
  model <- linear_reg() %>%
    fit(value ~ pq_ci_size, 
        data = df)
  return(model)
}


```

### plot_prediction

```{r}
plot_prediction <- function(pid) {
  
  # get polygon data
  current_data <- polys %>%
    filter(id == pid)

  # prep RGB data
  current_rgb <- input_data %>%
    filter(id == pid) %>%
    full_join(current_data %>%
                select(id, imagery, mean_iou),
              by = c('imagery', 'id'))

  print(
    ggplot(data = current_data) +
      geom_raster(data = current_rgb,
                  aes(x = x, y = y, fill = color_hex),
                  inherit.aes = FALSE) +
      scale_fill_manual(breaks = levels(input_data$color_hex),
                        values = levels(input_data$color_hex),
                        guide = 'none') +
      geom_sf(aes(geometry = bbox_geometry),
              color = 'black',
              fill = 'transparent') +
      geom_sf(aes(geometry = val_geometry,
              color = 'Validation'),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(name = '',
                         values = c('gray90')) +
      new_scale('color') +
      geom_sf(aes(geometry = pred_geometry,
              color = pq_ci_size),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(name = 'Prediction\n(Quality)',
                         breaks = pq_labels,
                         labels = pq_labels,
                         values = pq_colors,
                         drop = FALSE) +
      facet_grid(paste('ID:', str_remove(id, "^0+")) ~ imagery + paste('mIoU:', round(mean_iou, 2))) +
      theme_bw() +
      theme(axis.title = element_blank(),
            axis.text = element_blank)
  )

}
```

### plot_zonal_stats

```{r, warning = FALSE}
plot_zonal_stats <- function(var) {
  
  rts_fig <- ggplot(zonal_stats %>%
                      filter(rts_class == 'RTS'), 
                    aes(x = pq_ci_size, 
                        y = .data[[var]], 
                        color = pq_ci_size)) +
    geom_boxplot(outlier.shape = NA) +
    geom_signif(data = zonal_stats_contrasts %>%
                  filter(variable == var & rts_class == 'RTS'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label),
                stat="identity",
                manual = TRUE,
                tip_length = 0.1,
                inherit.aes = FALSE) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme_bw() +
    theme(axis.title.x = element_blank()) +
    coord_cartesian(ylim = zonal_stats_limits %>%
                      filter(variable == var & rts_class == 'RTS') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())
  
  delta_fig <- ggplot(zonal_stats %>%
                        filter(rts_class == 'Delta'), 
                      aes(x = pq_ci_size, 
                          y = .data[[var]], 
                          color = pq_ci_size)) +
    geom_boxplot(outlier.shape = NA) +
    geom_signif(data = zonal_stats_contrasts %>%
                  filter(variable == var & rts_class == 'Delta'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label),
                stat="identity",
                manual = TRUE,
                inherit.aes = FALSE) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme_bw() +
    theme(axis.title.x = element_blank()) +
    coord_cartesian(ylim = zonal_stats_limits %>%
                      filter(variable == var & rts_class == 'Delta') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())
  
  bg_fig <- ggplot(zonal_stats %>%
                     filter(rts_class == 'Background'), 
                   aes(x = pq_ci_size, 
                       y = .data[[var]], 
                       color = pq_ci_size)) +
    geom_boxplot(outlier.shape = NA) +
    geom_signif(data = zonal_stats_contrasts %>%
                  filter(variable == var & rts_class == 'Background'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label),
                stat="identity",
                manual = TRUE,
                inherit.aes = FALSE) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme_bw() +
    theme(axis.title.x = element_blank()) +
    coord_cartesian(ylim = zonal_stats_limits %>%
                      filter(variable == var & rts_class == 'Background') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())
  
  zonal_stats_fig <- ggarrange(rts_fig +
                                 theme(axis.text.x = element_blank(),
                                       axis.ticks.x = element_blank(),
                                       axis.title.y = element_blank()),
                               delta_fig +
                                 theme(strip.background.x = element_blank(),
                                       strip.text.x = element_blank(),
                                       axis.text.x = element_blank(),
                                       axis.ticks.x = element_blank()),
                               bg_fig +
                                 theme(strip.background.x = element_blank(),
                                       strip.text.x = element_blank(),
                                       axis.ticks.x = element_blank(),
                                       axis.title.y = element_blank()),
                               ncol = 1)
  
  return(zonal_stats_fig)
}
```

### pred_as_poly

```{r, include = FALSE}
pred_as_poly <- function(prediction, threshold = 0.5) {
  layer <- prediction[['prediction']]
  layer[layer >= threshold] <- 1
  layer[layer < threshold] <- 0
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = prediction) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'pred_bg',
                                tk_class == 1 ~ 'pred'),
           id = get_rast_id(prediction)) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('pred_geometry')
  if (!('pred_geometry' %in% colnames(poly))) {
    poly <- poly %>%
      mutate(pred_geometry = st_sfc(st_polygon(), crs = crs(prediction))) %>%
    st_set_geometry('pred_geometry')
  }
  
  return(poly)
}
```

### recall_precision

```{r, include = FALSE}
recall_precision <- function(truth, iou, thresholds) {
  
  df <- tibble(ground_truth = truth,
               iou_score = iou)
  precision <- c()
  recall <- c()
  
  for (threshold in thresholds) {
    pred_class <- if_else(iou >= threshold,
                          'positive',
                          'negative')
    
    df <- df %>%
      mutate(class = case_when(iou_score >= threshold & ground_truth == 1 ~ 'true positive',
                               iou_score >= threshold & ground_truth == 0 ~ 'false positive',
                               iou_score < threshold & ground_truth == 1 ~ 'false negative',
                               iou_score < threshold & ground_truth == 0 ~ 'true negative'))
    
    # precision = count(true positive)/(count(true positive) + count(false positive))
    precision <- c(precision,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false positive')))
                   )
    )
    
    # recall = count(true positive)/(count(true positive) + count(false negative))
    recall <- c(recall,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false negative')))
                   )
    )
    
  }
  
  recall <- c(recall, 0)
  precision <- c(precision, 1)
  
  output <- tibble(recall = recall,
                   precision = precision,
                   threshold = threshold)
  
  return(output)
  
}
```

### trim_outliers

```{r, include = FALSE}
trim_outliers <- function(x) {
  x_quant <- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  x_iqr <- IQR(x, na.rm = TRUE)
  x_trim <- x[x <= x_quant['75%'] + x_iqr*1.5 & x >= x_quant['25%'] - x_iqr*1.5]
  return(x_trim)
}
```

### val_as_poly

```{r, include = FALSE}
val_as_poly <- function(prediction) {
  layer <- prediction[['validation']]
  layer <- classify(layer, 
                    matrix(c(0, 0,
                             1, 1),
                           ncol = 2,
                           byrow = TRUE))
  current_id <- get_rast_id(prediction)
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = validation) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'val_bg',
                                tk_class == 1 ~ 'val'),
           id = current_id) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('val_geometry')
  
  return(poly)
}
```

## Prep Plot Variables

```{r}
imagery_labels <- c('Maxar', 'Planet', 'Sentinel-2')
imagery_labeller <- c('Maxar' = 'Maxar', 'Planet' = 'Planet', 'Sentinel-2' = 'Sentinel-2')
imagery_colors <- c('#FFCC00', '#0099AA', '#0000AA')

# prediction quality (pq)
pq_labels <- c('High', 'Expected', 'Low')
pq_colors <- c('#00CCFF', 'gray20', '#CC0000')
```


## Load Data

### Polygons

```{r}
rts_outlines <- st_read('./data/rts_polygons/rts_polygons_for_Yili_May_2022_v2.shp') %>%
  st_transform(crs = 3413) %>%
  select(id = ID, region, status = Act_or_Gen, code_id, rts_area = Shape_Area, Long)
```

### Download Files

```{r}
loc_dir <- './data'
gd_dir <- 'data/DATA_V3_GEOTIFFS'
# maxar_pred_dir <- 'MAXAR20230623_161858_p25062023'
maxar_pred_dir <- 'MAXAR20230621_022422_p21062023'
planet_pred_dir <- 'PLANET20230621_190115_p21062023'
sentinel_pred_dir <- 'SENTINEL220230621_171002_p21062023'

gd_pred_folders <- drive_ls(paste0(gd_dir, '/TESTSET_INFERENCE')) %>%
  filter(name ==  maxar_pred_dir |
           name == planet_pred_dir |
           name == sentinel_pred_dir)

gd_maxar_input_folders <- drive_ls(paste0(gd_dir, '/MAXAR')) %>%
  filter(str_detect(name, 'valtest'))
gd_planet_input_folders <- drive_ls(paste0(gd_dir, '/PLANET')) %>%
  filter(str_detect(name, 'valtest'))
gd_sentinel_input_folders<- drive_ls(paste0(gd_dir, '/SENTINEL2')) %>%
  filter(str_detect(name, 'valtest'))
```

```{r}
# check if prediction files have already been downloaded
loc_filepaths <- list.files(loc_dir,
                            full.names = TRUE,
                            recursive = TRUE)

# Maxar
maxar_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(maxar_pred_dir))
]
maxar_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('maxar/(', 
                    gd_maxar_input_folders$name[1], '|', 
                    gd_maxar_input_folders$name[2], ')'))
]

# Planet
planet_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(planet_pred_dir))
]
planet_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('planet/(', 
                    gd_planet_input_folders$name[1], '|', 
                    gd_planet_input_folders$name[2], ')'))
]

# Sentinel
sentinel_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(sentinel_pred_dir))
]
sentinel_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('sentinel/(', 
                    gd_sentinel_input_folders$name[1], '|', 
                    gd_sentinel_input_folders$name[2], ')'))
]
```

```{r}
if (length(maxar_pred_files) == length(planet_pred_files) & 
    length(maxar_pred_files) == length(sentinel_pred_files) & 
    length(maxar_pred_files) > 0) {
  
  print(paste('There are', length(maxar_pred_files), 'prediction tiles.'))
  
} else {
  
  # download Maxar predictions
  maxar_pred_filepath <- paste0(loc_dir, '/maxar/predictions-', maxar_pred_dir)
  maxar_pred_files <- drive_ls(gd_pred_folders %>%
                                 filter(str_detect(name, 'MAXAR')),
                               pattern = 'tif$') %>%
    arrange(name)
  
  maxar_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, maxar_pred_filepath)
    )
  
  maxar_pred_files <- list.files(maxar_pred_filepath,
                                 pattern = 'tif$',
                                 full.names = TRUE)
  
  # download Planet predictions
  planet_pred_filepath <- paste0(loc_dir, '/planet/predictions-', planet_pred_dir)
  planet_pred_files <- drive_ls(gd_pred_folders %>%
                                  filter(str_detect(name, 'PLANET')),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, planet_pred_filepath)
    )
  
  planet_pred_files <- list.files(planet_pred_filepath,
                                  pattern = 'tif$',
                                  full.names = TRUE)
  
  # download Sentinel-2 predictions
  sentinel_pred_filepath <- paste0(loc_dir, '/sentinel/predictions-', sentinel_pred_dir)
  sentinel_pred_files <- drive_ls(gd_pred_folders %>%
                                    filter(str_detect(name, 'SENTINEL2')),
                                  pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, sentinel_pred_filepath)
    )
  
  sentinel_pred_files <- list.files(sentinel_pred_filepath,
                                    pattern = 'tif$',
                                    full.names = TRUE)
  
}

rm(gd_pred_folders)
```

```{r}
if (length(maxar_input_files) == length(planet_input_files) & 
    length(maxar_input_files) == length(sentinel_input_files) &
    length(maxar_input_files > 0)) {
  
  print(paste('There are', length(maxar_input_files), 'input data tiles.'))
  
} else {
  
  # Download Maxar Input Data Layers  
  maxar_input_filepaths <- paste0(loc_dir, '/maxar/', gd_maxar_input_folders$name)
  
  maxar_input_files <- drive_ls(gd_maxar_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  maxar_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, maxar_input_filepaths[1])
    )
  
  maxar_input_files <- drive_ls(gd_maxar_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  maxar_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, maxar_input_filepaths[2])
    )
  
  maxar_input_files <- map(maxar_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  maxar_input_files <- unlist(maxar_input_files)
  
  # Download Planet Input Data Layers  
  planet_input_filepaths <- paste0(loc_dir, '/planet/', gd_planet_input_folders$name)
  
  planet_input_files <- drive_ls(gd_planet_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, planet_input_filepaths[1])
    )
  
  planet_input_files <- drive_ls(gd_planet_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, planet_input_filepaths[2])
    )
  
  planet_input_files <- map(planet_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  planet_input_files <- unlist(planet_input_files)
  
  # Download sentinel Input Data Layers  
  sentinel_input_filepaths <- paste0(loc_dir, '/sentinel/', gd_sentinel_input_folders$name)
  
  sentinel_input_files <- drive_ls(gd_sentinel_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, sentinel_input_filepaths[1])
    )
  
  sentinel_input_files <- drive_ls(gd_sentinel_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, sentinel_input_filepaths[2])
    )
  
  sentinel_input_files <- map(sentinel_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  sentinel_input_files <- unlist(sentinel_input_files)
  
}

rm(gd_maxar_input_folders, gd_planet_input_folders, gd_sentinel_input_folders)
```

### Maxar GeoTiffs

```{r, include = FALSE}
maxar_pred_dir_zscore <- 'MAXAR20230623_161858_p25062023'
maxar_pred_filepath_zscore <- paste0(loc_dir, '/maxar/predictions-', maxar_pred_dir_zscore)
maxar_pred_files_zscore <- list.files(maxar_pred_filepath_zscore,
                                 pattern = 'tif$',
                                 full.names = TRUE)

maxar_preds <- map(maxar_pred_files, ~ import_pred(.x))
maxar_preds_zscore <- map(maxar_pred_files_zscore, ~ import_pred(.x))

rm(maxar_pred_files)
```

```{r, include = FALSE}
maxar_input <- map(maxar_input_files, ~ rast(.x))
ids <- map_chr(maxar_input, ~ get_rast_id(.x))
names(maxar_input) <- ids

rm(maxar_input_files)
```


### Planet GeoTiffs

```{r, include = FALSE}
planet_preds <- map(planet_pred_files, ~ import_pred(.x))

rm(planet_pred_files)
```

```{r, include = FALSE}
planet_input <- map(planet_input_files, ~ rast(.x))
ids <- map_chr(planet_input, ~ get_rast_id(.x))
names(planet_input) <- ids

rm(planet_input_files)
```

### Sentinel GeoTiffs

```{r, include = FALSE}
sentinel_preds <- map(sentinel_pred_files, ~ import_pred(.x))

rm(sentinel_pred_files)
```

```{r, include = FALSE}
sentinel_input <- map(sentinel_input_files, ~ rast(.x))
ids <- map_chr(sentinel_input, ~ get_rast_id(.x))
names(sentinel_input) <- ids

rm(sentinel_input_files)
```


## Get Tile Bounding Boxes

```{r}
maxar_tiles <- maxar_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Maxar') %>%
  select(id, imagery, bbox_geometry)

planet_tiles <- planet_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Planet') %>%
  select(id, imagery, bbox_geometry)

sentinel_tiles <- sentinel_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Sentinel-2') %>%
  select(id, imagery, bbox_geometry)

tiles <- maxar_tiles %>%
  rbind.data.frame(planet_tiles) %>%
  rbind.data.frame(sentinel_tiles)

rm(maxar_tiles, planet_tiles, sentinel_tiles)
```

```{r}
polys <- tiles %>%
  left_join(rts_outlines %>%
              as_tibble() %>%
              rename(rts_geometry = geometry), 
            by = 'id') %>%
  st_as_sf(crs = st_crs(rts_outlines))

rm(tiles)
```


## Convert Predictions to Vector

### Calculate Best RTS Threshold

```{r}
# maxar_rts_threshold <- maxar_preds %>% 
#   map_dfr(~ calc_rts_threshold(.x, seq(0.35, 0.6, by = 0.01))) %>%
#   group_by(threshold) %>%
#   summarise(mean_iou = mean(mean_iou)) %>%
#   ungroup() %>%
#   filter(mean_iou == max(mean_iou)) %>%
#   select(threshold) %>%
#   as.numeric()
# 
# maxar_rts_threshold_zscore <- maxar_preds_zscore %>% 
#   map_dfr(~ calc_rts_threshold(.x, seq(0.35, 0.6, by = 0.01))) %>%
#   group_by(threshold) %>%
#   summarise(mean_iou = mean(mean_iou)) %>%
#   ungroup() %>%
#   filter(mean_iou == max(mean_iou)) %>%
#   select(threshold) %>%
#   as.numeric()
# 
# planet_rts_threshold <- planet_preds %>% 
#   map_dfr(~ calc_rts_threshold(.x, seq(0.35, 0.6, by = 0.01))) %>%
#   group_by(threshold) %>%
#   summarise(mean_iou = mean(mean_iou)) %>%
#   ungroup() %>%
#   filter(mean_iou == max(mean_iou)) %>%
#   select(threshold) %>%
#   as.numeric()
# 
# sentinel_rts_threshold <- sentinel_preds %>% 
#   map_dfr(~ calc_rts_threshold(.x, seq(0.35, 0.6, by = 0.01))) %>%
#   group_by(threshold) %>%
#   summarise(mean_iou = mean(mean_iou)) %>%
#   ungroup() %>%
#   filter(mean_iou == max(mean_iou)) %>%
#   select(threshold) %>%
#   as.numeric()
```
Maxar RTS Threshold: `r maxar_rts_threshold`
Planet RTS Threshold: `r planet_rts_threshold`
Sentinel RTS Threshold: `r sentinel_rts_threshold`

```{r}
maxar_pred_polys <- maxar_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x#, maxar_rts_threshold
      )
    ) %>%
  mutate(imagery = 'Maxar')

maxar_pred_polys_zscore <- maxar_preds_zscore %>%
  map_dfr(
    ~ pred_as_poly(
      .x#, maxar_rts_threshold_zscore
      )
    ) %>%
  mutate(imagery = 'Maxar')

planet_pred_polys <- planet_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x#, planet_rts_threshold
      )
    ) %>%
  mutate(imagery = 'Planet')

sentinel_pred_polys <- sentinel_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x#, sentinel_rts_threshold
      )
    ) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Prediction Polygons into `polys` SF Dataframe

```{r}
pred_polys <- maxar_pred_polys %>%
  rbind(planet_pred_polys) %>%
  rbind(sentinel_pred_polys)

polys <- polys %>%
  full_join(pred_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_pred_polys, planet_pred_polys, sentinel_pred_polys, pred_polys)
```


## Convert Validation to Vector

```{r}
maxar_val_polys <- maxar_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Maxar')

planet_val_polys <- planet_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Planet')

sentinel_val_polys <- sentinel_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Validation Polygons into `polys` SF Dataframe

```{r}
val_polys <- maxar_val_polys %>%
  rbind(planet_val_polys) %>%
  rbind(sentinel_val_polys)

polys <- polys %>%
  full_join(val_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_val_polys, planet_val_polys, sentinel_val_polys, val_polys)
```


## Convert Input Data to DF

```{r}
pred_ids <- c()
for (pred in maxar_preds) {
  pred_ids <- c(pred_ids, get_rast_id(pred))
}

maxar_input_filtered <- filter_input_data(maxar_input, pred_ids)
planet_input_filtered <- filter_input_data(planet_input, pred_ids)
sentinel_input_filtered <- filter_input_data(sentinel_input, pred_ids)

input_data <- maxar_input_filtered %>%
  map2_dfr(maxar_preds, ~ input_as_df(.x, .y)) %>%
  mutate(imagery = 'Maxar') %>%
  rbind.data.frame(planet_input_filtered %>%
                     map2_dfr(planet_preds, ~ input_as_df(.x, .y)) %>%
                     mutate(imagery = 'Planet')) %>%
  rbind.data.frame(sentinel_input_filtered %>%
                     map2_dfr(sentinel_preds, ~ input_as_df(.x, .y)) %>%
                     mutate(imagery = 'Sentinel-2')) %>%
  select(imagery, id, rts_class, x, y, 
         r, g, b, lum, nir, ndvi, ndwi, elev, sr, 
         r_stretch, g_stretch, b_stretch, color_hex, prediction)
print(nrow(input_data))
```


## Interactive Map of Features

```{r}
pal_viridis <- colorFactor("viridis", polys$imagery)

leaflet() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  addPolygons(data = polys %>%
                select(imagery, pred_geometry) %>%
                st_transform(crs = 4326), 
              color = ~ pal_viridis(imagery),
              fill = FALSE,
              weight = 2) %>%
  addLegend(data = polys, 
            pal = pal_viridis, 
            values = ~ imagery) %>%
  addPolygons(data = polys %>%
                select(val_geometry) %>%
                st_transform(crs = 4326), 
              color = 'black',
              fill = FALSE,
              weight = 2)
```

## IoU

### Calculate Intersection and Union

```{r}
polys <- polys %>%
  mutate(rts_int_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                                val_geometry), 
                                           ~ st_intersection(...)),
                                  crs = crs(polys)),
         rts_uni_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                                val_geometry), 
                                           ~ st_union(...)),
                                  crs = crs(polys)),
         bg_int_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                               val_bg_geometry), 
                                          ~ st_intersection(...)),
                                  crs = crs(polys)),
         bg_uni_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                               val_bg_geometry), 
                                          ~ st_union(...)),
                                  crs = crs(polys)))
```

### Calculate IoU

IoU (Calculated in Model)

|Imagery (normalization method)|Test IoU|Val IoU|
|:---:|:---:|:---:|
|Maxar (0-1)|0.75|0.69|
|Maxar (z-score)|0.73|0.72|
|Planet (0-1)|0.71|0.70|
|Sentinel-2 (0-1)|0.68|0.66|


```{r}
polys <- polys %>%
  mutate(rts_iou = as.numeric(st_area(rts_int_geometry)/st_area(rts_uni_geometry)),
         bg_iou = as.numeric(st_area(bg_int_geometry)/st_area(bg_uni_geometry)),
         mean_iou = (rts_iou + bg_iou)/2,
         mean_iou_v2 = case_when(
           st_is_empty(pred_geometry) ~ bg_iou,
           TRUE ~ (rts_iou + bg_iou)/2
         ))
```

```{r}
iou <- polys %>%
  as_tibble() %>%
  group_by(imagery) %>%
  summarise(mean_iou = round(mean(mean_iou), 2),
            mean_iou_v2 = round(mean(mean_iou_v2), 2)) %>%
  select(Imagery = imagery, `Val IoU` = mean_iou, `Val IoU (remove zeros)` = mean_iou_v2)
knitr::kable(iou, caption = 'IoU (Calculated Directly from Predictions)')
```


## Mean Average Precision

### Recall-Precision Curves

```{r}
polys <- polys %>%
  mutate(ground_truth = 1)

thresholds <- seq(0.2, 0.8, by = 0.1)

maxar_rts_rec_pre <- recall_precision(filter(polys, imagery == 'Maxar')$ground_truth, 
                                      filter(polys, imagery == 'Maxar')$rts_iou, 
                                      thresholds)

planet_rts_rec_pre <- recall_precision(filter(polys, imagery == 'Planet')$ground_truth, 
                                       filter(polys, imagery == 'Planet')$rts_iou, 
                                       thresholds)

sentinel_rts_rec_pre <- recall_precision(filter(polys, imagery == 'Sentinel-2')$ground_truth, 
                                         filter(polys, imagery == 'Sentinel-2')$rts_iou, 
                                         thresholds)

rts_rec_pre <- maxar_rts_rec_pre %>%
  mutate(imagery = 'Maxar') %>%
  rbind.data.frame(planet_rts_rec_pre %>%
                     mutate(imagery = 'Planet')) %>%
  rbind.data.frame(sentinel_rts_rec_pre %>%
                     mutate(imagery = 'Sentinel-2'))


maxar_bg_rec_pre <- recall_precision(filter(polys, imagery == 'Maxar')$ground_truth, 
                           filter(polys, imagery == 'Maxar')$bg_iou, 
                           thresholds)

planet_bg_rec_pre <- recall_precision(filter(polys, imagery == 'Planet')$ground_truth, 
                           filter(polys, imagery == 'Planet')$bg_iou, 
                           thresholds)

sentinel_bg_rec_pre <- recall_precision(filter(polys, imagery == 'Sentinel-2')$ground_truth, 
                           filter(polys, imagery == 'Sentinel-2')$bg_iou, 
                           thresholds)

bg_rec_pre <- maxar_bg_rec_pre %>%
  mutate(imagery = 'Maxar') %>%
  rbind.data.frame(planet_bg_rec_pre %>%
                     mutate(imagery = 'Planet')) %>%
  rbind.data.frame(sentinel_bg_rec_pre %>%
                     mutate(imagery = 'Sentinel-2'))

rec_pre <- rts_rec_pre %>%
  mutate(class = 'rts') %>%
  rbind.data.frame(bg_rec_pre %>%
                     mutate(class = 'bg'))

rm(maxar_rts_rec_pre, planet_rts_rec_pre, sentinel_rts_rec_pre,
   maxar_bg_rec_pre, planet_bg_rec_pre, sentinel_bg_rec_pre,
   rts_rec_pre, bg_rec_pre)
```

### MAP

```{r}
avg_pre <- rec_pre %>%
  group_by(imagery, class) %>%
  summarise(avg_pre = avg_precision(recall, precision))

mean_avg_pre <- avg_pre %>%
  group_by(imagery) %>%
  summarise(map = mean(avg_pre)) %>%
  mutate(x_loc = rep(0, 3),
         y_loc = seq(0.2, 0, length.out = 3),
         map_label = paste(imagery, 'MAP =', round(map, 2)))
```

### Plot

Precision measures false positives. Recall measures false negatives.

This figure will only be interesting once we have added in negative training data.

```{r}
arrow_data <- tibble(x = c(0.5, -0.28),
                     xend = c(1, -0.28),
                     y = c(-0.24, 0.5),
                     yend = c(-0.24, 1),
                     imagery = rep('Maxar', 2),
                     class = rep('rts', 2))
label_data <- tibble(x = c(0, -0.28),
                     y = c(-0.24, 0),
                     label = c('Fewer False Negatives    ',
                               'Fewer False Positives    '),
                     angle = c(0, 90),
                     imagery = rep('Maxar', 2),
                     class = rep('rts', 2))

rec_pre_plot <- ggplot(rec_pre,
                       aes(x = recall, y = precision, color = imagery, linetype = class)) +
  geom_line() +
  geom_text(data = mean_avg_pre,
            aes(x = x_loc, y = y_loc, label = map_label),
            inherit.aes = FALSE,
            hjust = 0,
            vjust = 0) +
  geom_segment(data = arrow_data,
               aes(x = x, y = y,
                   xend = xend, yend = yend),
               inherit.aes = FALSE,
               arrow = arrow(type = 'closed', length = unit(0.02, 'npc'))) +
  geom_text(data = label_data,
            aes(x = x, y = y, label = label, angle = angle),
            inherit.aes = FALSE,
            size = 3.5,
            hjust = 0,
            vjust = 0.4,
            color = 'black') +
  scale_x_continuous(name = 'Recall') +
  scale_y_continuous(name = 'Precision') +
  scale_color_manual(labels = imagery_labels,
                     values = imagery_colors) +
  scale_linetype_manual(labels = c('Background', 'RTS'),
                        values = c('dashed', 'solid')) +
  # facet_grid(. ~ imagery) +
  coord_fixed(xlim = c(0, 1),
                  ylim = c(0, 1),
                  clip = 'off') +
  theme_bw() +
  theme(legend.title = element_blank(),
        plot.margin = margin(t = 5.5, r = 5.5, b = 30, l = 30, unit = 'pt'))
rec_pre_plot
```

## Performance by Feature Size

### Calculate Area

```{r}
polys <- polys %>%
  mutate(rts_area = round(as.numeric(st_area(val_geometry)), 2),
         rts_area_class = round(rts_area, -2))

poly_size_summary <- polys %>%
  group_by(imagery, rts_area_class) %>%
  summarise(iou_mean = mean(mean_iou),
            iou_se = sd(mean_iou)/sqrt(n()))
```

### Size Distribution by Region

```{r}
sf_use_s2(FALSE)
arctic_box <- tibble(lon = c(-180,180,180,-180,-180),
                    lat = c(90,90,50,50,90)) %>%
  st_as_sf(coords = c("lon","lat"),
           crs = "EPSG:4326") %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON") %>% 
  smoothr::densify(max_distance = 1)

world_north <- world %>%
  st_crop(arctic_box) %>%
  st_transform(crs = st_crs(rts_outlines)) %>%
  select(name_long, continent, region_un, subregion)

world_north_buffer <- world_north %>%
  st_buffer(50000)

if (!('name_long' %in% colnames(polys))) {
  
  polys <- polys %>%
  st_join(world_north_buffer)
  
}

polys <- polys %>%
  mutate(yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
                        TRUE ~ 'Other'))
# 
# rts_outlines <- rts_outlines %>%
#   mutate(yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
#                         TRUE ~ 'Other'))
# 
# ggplot() +
#   geom_sf(data = world_north, fill = 'transparent') +
#   geom_sf(data = rts_outlines,
#           aes(color = yg),
#           linewidth = 1)
```

```{r}
ggplot(polys, aes(x = rts_area, fill = yg)) +
  geom_histogram(position = position_dodge(), bins = 11) +
  scale_fill_manual(values = c('gray50', 'gray20')) +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'Count') +
  theme_bw() +
  theme(legend.title = element_blank())
```

```{r}
rts_summaries <- polys %>%
  as_tibble() %>%
  group_by(yg) %>%
  summarise(mean_size = mean(rts_area),
            min_size = min(rts_area),
            max_size = max(rts_area),
            median_size = median(rts_area))
knitr::kable(rts_summaries)
```

### Plot

Raw IoU Scores:

This is complicated by the fact that the rts_area column is calculated from the raster validation layer, which may contain several RTS features within one tile. Use rts_area (from the original RTS delineation), instead.

Run `nls` models and bootstrap parameters

```{r}
# maxar_iou_nls <- nls(mean_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Maxar'))
# 
# maxar_iou_boot <- nlsBoot(maxar_iou_nls, 500000)
# saveRDS(maxar_iou_nls, './data/models/maxar_iou_nls.RData')
# saveRDS(maxar_iou_boot, './data/models/maxar_iou_boot.RData')

maxar_iou_nls <- readRDS('./data/models/maxar_iou_nls.RData')
maxar_iou_boot <- readRDS('./data/models/maxar_iou_boot.RData')
```

```{r}
# planet_iou_nls <- nls(mean_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Planet'))
# 
# planet_iou_boot <- nlsBoot(planet_iou_nls, 500000)
# saveRDS(planet_iou_nls, './data/models/planet_iou_nls.RData')
# saveRDS(planet_iou_boot, './data/models/planet_iou_boot.RData')

planet_iou_nls <- readRDS('./data/models/planet_iou_nls.RData')
planet_iou_boot <- readRDS('./data/models/planet_iou_boot.RData')
```

```{r}
# sentinel_iou_nls <- nls(mean_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Sentinel-2'))
# 
# sentinel_iou_boot <- nlsBoot(sentinel_iou_nls, 500000)
# saveRDS(sentinel_iou_nls, './data/models/sentinel_iou_nls.RData')
# saveRDS(sentinel_iou_boot, './data/models/sentinel_iou_boot.RData')

sentinel_iou_nls <- readRDS('./data/models/sentinel_iou_nls.RData')
sentinel_iou_boot <- readRDS('./data/models/sentinel_iou_boot.RData')
```

Bootstrap predictions for plotting the `nls` models

```{r}
newdata <- tibble(rts_area = seq(min(polys$rts_area), max(polys$rts_area), length.out = 200))
```

```{r}
# maxar_iou_predict <- nlsBootPredict(maxar_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(maxar_iou_predict, './data/models/maxar_iou_predict.RData')

maxar_iou_predict <- readRDS('./data/models/maxar_iou_predict.RData')
maxar_iou_ci <- newdata %>%
  cbind(maxar_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `2.5%`, upr = `97.5%`) %>%
  mutate(predict = predict(maxar_iou_nls, newdata),
         predict_lwr = maxar_iou_boot[["bootCI"]][2, 2] * rts_area / (maxar_iou_boot[["bootCI"]][1, 3] + rts_area),
         predict_upr = maxar_iou_boot[["bootCI"]][2, 3] * rts_area / (maxar_iou_boot[["bootCI"]][1, 2] + rts_area))
```

```{r}
# planet_iou_predict <- nlsBootPredict(planet_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(planet_iou_predict, './data/models/planet_iou_predict.RData')

planet_iou_predict <- readRDS('./data/models/planet_iou_predict.RData')
planet_iou_ci <- newdata %>%
  cbind(planet_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `2.5%`, upr = `97.5%`) %>%
  mutate(predict = predict(planet_iou_nls, newdata),
         predict_lwr = planet_iou_boot[["bootCI"]][2, 2] * rts_area / (planet_iou_boot[["bootCI"]][1, 3] + rts_area),
         predict_upr = planet_iou_boot[["bootCI"]][2, 3] * rts_area / (planet_iou_boot[["bootCI"]][1, 2] + rts_area))
```

```{r}
# sentinel_iou_predict <- nlsBootPredict(sentinel_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(sentinel_iou_predict, './data/models/sentinel_iou_predict.RData')

sentinel_iou_predict <- readRDS('./data/models/sentinel_iou_predict.RData')
sentinel_iou_ci <- newdata %>%
  cbind(sentinel_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `2.5%`, upr = `97.5%`) %>%
  mutate(predict = predict(sentinel_iou_nls, newdata),
         predict_lwr = sentinel_iou_boot[["bootCI"]][2, 2] * rts_area / (sentinel_iou_boot[["bootCI"]][1, 3] + rts_area),
         predict_upr = sentinel_iou_boot[["bootCI"]][2, 3] * rts_area / (sentinel_iou_boot[["bootCI"]][1, 2] + rts_area))
```

```{r}
# Add the predictions to `polys`
predictions <- c(predict(maxar_iou_nls, 
                         filter(polys, imagery == 'Maxar')),
                 predict(planet_iou_nls, 
                         filter(polys, imagery == 'Planet')),
                 predict(sentinel_iou_nls, 
                         filter(polys, imagery == 'Sentinel-2')))

polys <- polys %>%
  mutate(
    predict = predictions,
    predict_lwr = case_when(
      imagery == 'Maxar' ~ maxar_iou_boot[["bootCI"]][2, 2] * rts_area / (maxar_iou_boot[["bootCI"]][1, 3] + rts_area),
      imagery == 'Planet' ~ planet_iou_boot[["bootCI"]][2, 2] * rts_area / (planet_iou_boot[["bootCI"]][1, 3] + rts_area),
      imagery == 'Sentinel-2' ~ sentinel_iou_boot[["bootCI"]][2, 2] * rts_area / (sentinel_iou_boot[["bootCI"]][1, 3] + rts_area)
    ),
    predict_upr = case_when(
      imagery == 'Maxar' ~ maxar_iou_boot[["bootCI"]][2, 3] * rts_area / (maxar_iou_boot[["bootCI"]][1, 2] + rts_area),
      imagery == 'Planet' ~ planet_iou_boot[["bootCI"]][2, 3] * rts_area / (planet_iou_boot[["bootCI"]][1, 2] + rts_area),
      imagery == 'Sentinel-2' ~ sentinel_iou_boot[["bootCI"]][2, 3] * rts_area / (sentinel_iou_boot[["bootCI"]][1, 2] + rts_area)
    )
  )
```

Plot the Size/Performance plot

```{r}
iou_ci <- maxar_iou_ci %>%
  mutate(imagery = 'Maxar') %>%
  rbind(planet_iou_ci %>%
          mutate(imagery = 'Planet')) %>%
  rbind(sentinel_iou_ci %>%
          mutate(imagery = 'Sentinel-2'))

rm(maxar_iou_nls, maxar_iou_predict, maxar_iou_ci,
   planet_iou_nls, planet_iou_predict, planet_iou_ci,
   sentinel_iou_nls, sentinel_iou_predict, sentinel_iou_ci,
   newdata)
```

```{r}
ggplot(polys, aes(x = rts_area, y = mean_iou, color = imagery)) +
  geom_point(size = 1) +
  # geom_smooth(method="nls",
  #             method.args = list(formula = y ~ Vmax * x / (Km + x),
  #                                start = list(Km = 50, Vmax = 2)),
  #             data = polys,
  #             se = FALSE,
  #             aes(color = imagery),
  #             linetype = 'dashed') +
  geom_ribbon(data = iou_ci,
            aes(x = rts_area, ymin = predict_lwr, ymax = predict_upr, group = imagery),
            alpha = 0.2,
            inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = predict, color = imagery),
            inherit.aes = FALSE) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels) +
  theme_bw() +
  theme(legend.title = element_blank())
```


## Active vs. General RTS Performance

```{r}
iou_by_rts_status <- polys %>%
  as_tibble() %>%
  group_by(imagery, status) %>%
  summarise(mean_iou = mean(mean_iou))
```

```{r}
rts_status_lm <- lm(mean_iou ~ imagery * status,
                             data = polys)
rts_status_contrasts <- emmeans(rts_status_lm,
        pairwise ~ status | imagery,
        adjust = 'tukey')

rts_status_pvalues <- tibble(
  imagery = summary(rts_status_contrasts)$contrasts$imagery,
  p_val = summary(rts_status_contrasts)$contrasts$p.value,
  x_pos = rep(1.5, 3),
  star_y_pos = rep(0.9, 3),
  label_y_pos = rep(0.95, 3)
) %>%
  mutate(p_label = paste0('p-value = ', round(p_val, 3)),
         star_label = assign_conf_stars(p_val))
knitr::kable(rts_status_pvalues)
```

### Plot

It is possible to get rid of the inner panel borders, if I decide that looks better: <https://stackoverflow.com/questions/46220242/ggplot2-outside-panel-border-when-using-facet>

```{r}
ggplot(polys, 
       aes(x = status, 
           y = mean_iou, 
           group = interaction(imagery, status))) +
  geom_point(position = position_jitterdodge(seed = 1, 
                                             dodge.width = 0.9, 
                                             jitter.width = 0.5),
             aes(color = imagery),
             size = 1,
             alpha = 0.1) +
  geom_violin(aes(color = imagery),
              fill = 'gray60',
              linewidth = 0.75,
              alpha = 0.4,
              draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_text(data = rts_status_pvalues,
            aes(x = x_pos, y = star_y_pos, label = star_label),
            inherit.aes = FALSE) +
  # geom_text(data = rts_status_pvalues,
  #           aes(x = x_pos, y = label_y_pos, label = p_label),
  #           inherit.aes = FALSE) +
  scale_y_continuous(name = 'IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels,
                     guide = 'none') +
  facet_wrap(~ imagery, 
             strip.position = 'bottom', 
             scales = 'free_x',
             labeller = labeller(imagery = imagery_labeller)) +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank(),
        panel.spacing = unit(0, "lines"), 
        strip.background = element_blank(),
        strip.placement = "outside")
```

```{r}
poly_status_size_summary <- polys %>%
  group_by(imagery, status, rts_area_class) %>%
  summarise(iou_mean = mean(mean_iou),
            iou_se = sd(mean_iou)/sqrt(n()))
```

```{r}
ggplot(poly_status_size_summary, 
       aes(x = rts_area_class, y = iou_mean, color = imagery)) +
  geom_point(size = 2, aes(shape = status)) +
  # geom_errorbar(aes(ymin = iou_mean - iou_se, ymax = iou_mean + iou_se)) +
  # geom_smooth(method = 'gam', formula = y ~ s(x, bs = "cs"),
  #             aes(linetype = status)) +
  geom_smooth(method="nls",
              method.args = list(formula = y ~ Vmax * x / (Km + x),
                                 start = list(Km = 50, Vmax = 2)),
              data = poly_status_size_summary,
              se = FALSE,
              aes(color = imagery, linetype = status)) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels) +
  scale_fill_manual(values = imagery_colors,
                     labels = imagery_labels) +
  scale_shape_manual(values = c(16, 1)) +
  facet_grid(imagery ~ .) +
  theme_bw() +
  theme(legend.title = element_blank()) + 
  coord_cartesian(ylim = c(0, 1)) 
```


## Drivers of Unexpected RTS Prediction Performance

### Classify Features Using Confidence Interval Approach

This approach first uses the 95% CI of the model parameters to determine whether RTS features were predicted better or worse than expected based on the model. Next, the threshold at which RTS size doesn't impact IoU is determined from where the slope of the model approaches 0 (currently using slope < 1e-06) for each imagery type. RTS features smaller than this threshold that were predicted better than expected are analyzed later to determine why some small RTS can be identified from the imagery.


```{r, include = FALSE}
# take the derivative of the non-linear function to find where the slope approaches 0
maxar_d1 <- D(expression(y = 0.6946343 * x / (237.8842 + x)), name = 'x')
planet_d1 <- D(expression(y = 0.6908137 * x / (297.8871169 + x)), name = 'x')
sentinel_d1 <- D(expression(y = 0.6839025 * x / (250.2487224 + x)), name = 'x')

# estimate where the derivative crosses 1e-06
estimate_grid <- tibble(rts_area = seq(12000, 15000, by = 0.1))

maxar_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(maxar_d1, rts_area))
planet_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(planet_d1, rts_area))
sentinel_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(sentinel_d1, rts_area))

maxar_cross <- maxar_est %>%
  slice(which.min(abs(1e-06-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-06
planet_cross <- planet_est %>%
  slice(which.min(abs(1e-06-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-06
sentinel_cross <- sentinel_est %>%
  slice(which.min(abs(1e-06-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-06

size_thresholds <- tibble(imagery = c('Maxar', 'Planet', 'Sentinel-2'),
                          rts_threshold = c(maxar_cross, 
                                            planet_cross, 
                                            sentinel_cross))

# plot to confirm
ggplot(iou_ci, aes(x = rts_area)) +
  stat_function(fun = function(x) 0.6946343/(237.8842 + x) - 0.6946343 * x/(237.8842 + x)^2) +
  # geom_line(data = iou_ci, 
  #           aes(y = d1),
  #           color = 'gray20') +
  geom_hline(yintercept = 1e-06,
             color = 'blue') +
  geom_vline(xintercept = maxar_cross,
             color = 'red') +
  scale_y_continuous(limits = c(9e-07, 1.1e-06)) +
  scale_x_continuous(limits = c(10000, 15000)) +
  ggtitle('Maxar')

ggplot(iou_ci, aes(x = rts_area)) +
  stat_function(fun = function(x) 0.6908137/(297.8871169 + x) - 0.6908137 * x/(297.8871169 + x)^2) +
  # geom_line(data = iou_ci, 
  #           aes(y = d1),
  #           color = 'gray20') +
  geom_hline(yintercept = 1e-06,
             color = 'blue') +
  geom_vline(xintercept = planet_cross,
             color = 'red') +
  scale_y_continuous(limits = c(9e-07, 1.1e-06)) +
  scale_x_continuous(limits = c(10000, 15000)) +
  ggtitle('Planet')

ggplot(iou_ci, aes(x = rts_area)) +
  stat_function(fun = function(x) 0.6839025/(250.2487224 + x) - 0.6839025 * x/(250.2487224 + x)^2) +
  # geom_line(data = iou_ci, 
  #           aes(y = d1),
  #           color = 'gray20') +
  geom_hline(yintercept = 1e-06,
             color = 'blue') +
  geom_vline(xintercept = sentinel_cross,
             color = 'red') +
  scale_y_continuous(limits = c(9e-07, 1.1e-06)) +
  scale_x_continuous(limits = c(10000, 15000)) +
  ggtitle('Sentinel-2')

rm(maxar_d1, planet_d1, sentinel_d1,
   maxar_est, planet_est, sentinel_est,
   maxar_cross, planet_cross, sentinel_cross,
   estimate_grid)
```

```{r}
polys <- polys %>%
  mutate(
    rts_threshold = case_when(
      imagery == 'Maxar' ~ filter(size_thresholds, imagery == 'Maxar')$rts_threshold,
      imagery == 'Planet' ~ filter(size_thresholds, imagery == 'Planet')$rts_threshold,
      imagery == 'Sentinel-2' ~ filter(size_thresholds, imagery == 'Sentinel-2')$rts_threshold
    ),
    pq_ci = factor(
      case_when(
        mean_iou > predict_upr ~ 'High',
        mean_iou < predict_lwr ~ 'Low',
        TRUE ~ 'Expected'
      ),
      levels = c('High', 'Expected', 'Low')),
    pq_ci_size = factor(
      case_when(
        mean_iou > predict_upr & rts_area <= rts_threshold ~ 'High',
        mean_iou < predict_lwr & rts_area > rts_threshold ~ 'Low',
        TRUE ~ 'Expected'
      ),
      levels = c('High', 'Expected', 'Low'))
  )
```

```{r}
ggplot(polys, 
       aes(x = rts_area, 
           y = mean_iou, 
           shape = imagery)) +
  geom_point(aes(color = pq_ci), size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, 
                  ymin = predict_lwr, 
                  ymax = predict_upr, 
                  group = imagery),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci,
            aes(x = rts_area, y = predict, color = imagery),
            inherit.aes = FALSE) +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  scale_shape(name = 'Imagery') +
  theme_bw()# +
  # coord_cartesian(ylim = c(0, 1))

ggplot(polys, 
       aes(x = rts_area, 
           y = mean_iou)) +
  geom_point(aes(color = pq_ci), size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, ymin = predict_lwr, ymax = predict_upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = predict, color = imagery),
            inherit.aes = FALSE) +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  theme_bw() +
  # coord_cartesian(ylim = c(0, 1)) +
  facet_grid(. ~ imagery)

ggplot(polys, 
       aes(x = rts_area, 
           y = mean_iou)) +
  geom_point(aes(color = pq_ci_size, 
                 shape = imagery),
             size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, 
                  ymin = predict_lwr, 
                  ymax = predict_upr, 
                  group = imagery),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci,
            aes(x = rts_area, y = predict, color = imagery),
            inherit.aes = FALSE) +
  geom_vline(data = size_thresholds,
             aes(xintercept = rts_threshold, color = imagery),
            linetype = 'dashed') +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_shape(name = 'Imagery') +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  theme_bw()# +
  # coord_cartesian(ylim = c(0, 1))

ggplot(polys, 
       aes(x = rts_area, 
           y = mean_iou)) +
  geom_point(aes(color = pq_ci_size), size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, 
                  ymin = predict_lwr, 
                  ymax = predict_upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci,
            aes(x = rts_area, y = predict, color = imagery),
            inherit.aes = FALSE) +
  geom_vline(data = size_thresholds,
             aes(xintercept = rts_threshold, color = imagery),
            linetype = 'dashed') +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  theme_bw() +
  # coord_cartesian(ylim = c(0, 1)) +
  facet_grid(. ~ imagery)
```

```{r}
knitr::kable(size_thresholds)
knitr::kable(polys %>%
               as_tibble() %>%
               count(imagery, pq_ci_size) %>%
               pivot_wider(names_from = pq_ci_size, values_from = n))
```

Visualize the RTS predictions

```{r fig.width = 12, fig.height = 4.8}
pids <- unique(polys$id)

walk(pids,
    ~ plot_prediction(.x))
```

Is performance class the same across imagery sources for most RTS features?

```{r}
polys <- polys %>%
  mutate(
    pq_ci_size_offset = case_when(
      imagery == 'Maxar' ~ as.numeric(pq_ci_size) - 0.2,
      imagery == 'Planet' ~ as.numeric(pq_ci_size),
      imagery == 'Sentinel-2' ~ as.numeric(pq_ci_size) + 0.2
      )
    )

rts_pq <- polys %>%
  as_tibble() %>%
  select(id, imagery, rts_area, name_long, pq_ci_size) %>%
  mutate(
    pq_ci_size_high = case_when(pq_ci_size == 'High' ~ 1,
                                TRUE ~ 0),
    pq_ci_size_expected = case_when(pq_ci_size == 'Expected' ~ 1,
                                    TRUE ~ 0),
    pq_ci_size_low = case_when(pq_ci_size == 'Low' ~ 1,
                               TRUE ~ 0)
  ) %>%
  group_by(id) %>%
  summarise(High = sum(pq_ci_size_high),
            Expected = sum(pq_ci_size_expected),
            Low = sum(pq_ci_size_low)) %>%
  pivot_longer(High:Low, 
               names_to = 'pq_ci_size', 
               values_to = 'n') %>%
  group_by(id) %>%
  mutate(
    pq_ci_size = factor(pq_ci_size,
                        levels = c('High', 'Expected', 'Low')),
    group_max = max(n),
    group_pq_max = pq_ci_size[which(n == max(n))]
  ) %>%
  ungroup() %>%
  mutate(
    group_pq_2nd = case_when(
      n == 1 ~ pq_ci_size,
      TRUE ~ NA
      ),
    plotting_order = case_when(
      group_max == 2 & group_pq_max == 'High' & group_pq_2nd == 'Low' ~ 1,
      group_max == 3 & group_pq_max == 'High' ~ 2,
      group_max == 2 & group_pq_max == 'High' & group_pq_2nd == 'Expected' ~ 3,
      group_max == 2 & group_pq_max == 'Expected' & group_pq_2nd == 'High' ~ 4,
      group_max == 3 & group_pq_max == 'Expected' ~ 5,
      group_max == 2 & group_pq_max == 'Expected' & group_pq_2nd == 'Low' ~ 6,
      group_max == 2 & group_pq_max == 'Low' & group_pq_2nd == 'Expected' ~ 7,
      group_max == 3 & group_pq_max == 'Low' ~ 8
    )
  ) %>%
  arrange(plotting_order, id) %>%
  mutate(id = factor(id,
                     levels = c(unique(.$id))))

polys <- polys %>%
  mutate(id = factor(id,
                     levels = c(unique(rts_pq$id))))
```

```{r, fig.width = 4, fig.height = 6}
ggplot(polys, 
       aes(x = pq_ci_size_offset, y = id, color = imagery)) +
  geom_point() +
  scale_x_continuous(name = 'Prediction Quality',
                     breaks = c(1, 2, 3),
                     labels = pq_labels) +
  scale_y_discrete(name = 'RTS Features') +
  scale_color_manual(values = imagery_colors) +
  # facet_grid(name_long ~ ., scales = 'free_y') +
  theme_bw() +
  theme(axis.text.y = element_blank(),
        legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  coord_fixed(ratio = 1/10)
```

```{r, fig.width = 4, fig.height = 6}
ggplot(rts_pq %>%
         filter(n != 0), 
       aes(x = pq_ci_size, y = id, color = pq_ci_size, size = n)) +
  geom_point() +
  scale_x_discrete(name = 'Prediction Quality') +
  scale_y_discrete(
    name = 'RTS Features',
    limits = rev
    ) +
  scale_color_manual(name = 'Prediction Quality',
                   values = pq_colors) +
  scale_size(name = 'Model Count',
             breaks = c(1, 2, 3),
             range = c(0.5, 2.5)) +
  theme_bw() +
  theme(
    # axis.text.x = element_blank(),
    axis.text.y = element_blank()
    ) +
  coord_fixed(ratio = 1/10)
```

### Zonal Statistics

```{r}
zonal_stats <- input_data %>%
  group_by(imagery, id, rts_class) %>%
  summarise(across(r:sr, mean, .names = "{.col}_mean"),
            across(r:sr, sd, .names = "{.col}_sd")) %>%
  pivot_wider(names_from = 'rts_class', 
              values_from = c(r_mean:sr_sd)) %>%
  mutate(r_mean_delta = (r_mean_rts - r_mean_bg),
         b_mean_delta = (b_mean_rts - b_mean_bg),
         g_mean_delta = (g_mean_rts - g_mean_bg),
         lum_mean_delta = (lum_mean_rts - lum_mean_bg),
         nir_mean_delta = (nir_mean_rts - nir_mean_bg),
         ndvi_mean_delta = (ndvi_mean_rts - ndvi_mean_bg),
         ndwi_mean_delta = (ndwi_mean_rts - ndwi_mean_bg),
         elev_mean_delta = (elev_mean_rts - elev_mean_bg),
         sr_mean_delta = (sr_mean_rts - sr_mean_bg),
         r_sd_delta = (r_sd_rts - r_sd_bg),
         b_sd_delta = (b_sd_rts - b_sd_bg),
         g_sd_delta = (g_sd_rts - g_sd_bg),
         lum_sd_delta = (lum_sd_rts - lum_sd_bg),
         nir_sd_delta = (nir_sd_rts - nir_sd_bg),
         ndvi_sd_delta = (ndvi_sd_rts - ndvi_sd_bg),
         ndwi_sd_delta = (ndwi_sd_rts - ndwi_sd_bg),
         elev_sd_delta = (elev_sd_rts - elev_sd_bg),
         sr_sd_delta = (sr_sd_rts - sr_sd_bg)) %>%
  pivot_longer(r_mean_rts:sr_sd_delta, 
               names_to = 'variable', 
               values_to = 'value') %>%
  separate(variable, 
           into = c('variable', 'metric', 'rts_class'), 
           sep = '_') %>%
  mutate(rts_class = factor(case_when(rts_class == 'rts' ~ 'RTS',
                                      rts_class == 'bg' ~ 'Background',
                                      rts_class == 'delta' ~ 'Delta'),
                            levels = c('RTS', 'Delta', 'Background'))) %>%
  pivot_wider(names_from = c('variable', 'metric'),
              values_from = 'value') %>%
  right_join(polys %>%
               as_tibble() %>%
               select(c('id', 'imagery', 'region', 'status', 'rts_area',
                        'mean_iou', 'name_long', 'yg',
                        'predict', 'predict_lwr', 'predict_upr',
                        'rts_threshold',
                        'pq_ci',
                        'pq_ci_size')),
             by = c('id', 'imagery'))
```

```{r}
model_output <- zonal_stats %>%
  select(imagery:sr_sd, pq_ci_size) %>%
  pivot_longer(r_mean:sr_sd, names_to = 'variable', values_to = 'value') %>%
  group_by(rts_class, imagery, variable) %>%
  nest() %>% 
  mutate(models = map(data, possibly(my_lm, otherwise = NA)),
         summary = map(models, possibly(lm_summary, otherwise = NA)),
         contrasts = map(models, possibly(lm_contrasts, otherwise = NA)))
```

```{r}
zonal_stats_contrasts <- model_output %>%
  select(imagery, rts_class, variable, contrasts) %>%
  unnest(cols = c(contrasts)) %>%
  filter(p_value <= 0.1) %>%
  separate_wider_delim(contrast, 
                       delim = ' - ', 
                       names = c('x_min', 'x_max'), 
                       cols_remove = FALSE) %>%
  mutate(x_min = as.numeric(factor(x_min,
                                   levels = pq_labels)) + 0.05,
         x_max = as.numeric(factor(x_max,
                                   levels = pq_labels)) - 0.05)
```

```{r}
# calculate figure y-limits by hand
# (1.5*IQR is the upper and lower whisker limit; 1.05 is the default axis expansion by ggplot)
zonal_stats_limits <- zonal_stats %>%
  select(imagery:sr_sd, pq_ci_size) %>%
  pivot_longer(r_mean:sr_sd,  names_to = 'variable', values_to = 'value') %>%
group_by(imagery, pq_ci_size, rts_class, variable) %>%
  summarise(lwr = min(trim_outliers(value), na.rm = TRUE),
            upr = max(trim_outliers(value), na.rm = TRUE)) %>%
  mutate(lim_lwr = upr - (upr - lwr)*1.05,
         lim_upr = lwr + (upr - lwr)*1.05) %>%
  group_by(variable, rts_class) %>%
  summarise(lwr = min(lim_lwr),
            upr = max(lim_upr))
```

```{r}
zonal_stats_contrasts <- zonal_stats_contrasts %>%
  left_join(zonal_stats_limits, by = c('variable', 'rts_class')) %>%
  group_by(imagery, rts_class, variable) %>%
  mutate(n = n(),
         y = case_when(n >= 2 & contrast == 'High - Low' ~ lwr + (upr - lwr)*1.15,
                       TRUE ~ upr),
         upr = case_when(n >= 2 & contrast == 'High - Low' ~ lwr + (upr - lwr)*1.25,
                         TRUE ~ lwr + (upr - lwr)*1.1))

# add new upr limits back to limits tibble
zonal_stats_limits <- zonal_stats_limits %>%
  left_join(zonal_stats_contrasts %>%
              select(imagery, rts_class, variable, upr) %>%
              group_by(rts_class, variable) %>%
              summarise(new_upr = max(upr)),
            by = c('rts_class', 'variable')) %>%
  mutate(upr = case_when(!is.na(new_upr) ~ new_upr,
                         TRUE ~ upr)) %>%
  select(-new_upr)

```

These plots summarize the input data values (mean or standard deviation) in RTS cells, background cells, and the normalized difference between the two (`Delta = RTS - Background`). Most of the input layer names should be self explanatory, but for the others:

lum = [luminance](https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color) = `0.299*r + 0.587*g + 0.114*b` 

sr = shaded relief

```{r, include = FALSE}
variables <- colnames(zonal_stats %>%
                        ungroup() %>%
                        select(r_mean:sr_sd))
zonal_stats_figs <- map(variables,
                        ~ plot_zonal_stats(.x))
names(zonal_stats_figs) <- variables
```

A few takeaway points:

-   NIR and NDVI (mean) figures indicate that RTS are predicted poorly where background cells have low NDVI/plant growth (plants reflect NIR, so have a higher NIR value). I.e. it's harder for the model to find the RTS where there's not much plant growth across the landscape.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['nir_mean']]
zonal_stats_figs[['ndvi_mean']]
```

-   NDWI (mean) figure indicates that RTS features are predicted better where it's drier (fewer lakes?).

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['ndwi_mean']]
```

-   The standard deviation of elevation figure indicates that where there is higher variability in elevation within RTS relative to the background cells, RTS features are identified more easily. I.e. smooth landscape with uneven RTS is easy for the model to find.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['elev_sd']]
```

I didn't find much interesting about the rest of these figures, but they are included  here for completeness:

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['r_mean']]
zonal_stats_figs[['g_mean']]
zonal_stats_figs[['b_mean']]
zonal_stats_figs[['lum_mean']]
zonal_stats_figs[['elev_mean']]
zonal_stats_figs[['sr_mean']]
zonal_stats_figs[['r_sd']]
zonal_stats_figs[['g_sd']]
zonal_stats_figs[['b_sd']]
zonal_stats_figs[['lum_sd']]
zonal_stats_figs[['nir_sd']]
zonal_stats_figs[['ndvi_sd']]
zonal_stats_figs[['ndwi_sd']]
zonal_stats_figs[['sr_sd']]
```

### Prediction Probability

```{r}
input_data_rts_summary <- input_data %>%
  group_by(imagery, id, rts_class) %>%
  summarise(across(c(r:sr, prediction), ~ mean(.x)))
```

```{r}
ggplot(input_data) +
  # geom_point() +
  geom_bin_2d(data = input_data %>%
                filter(rts_class == 'rts'),
              aes(x = ndvi, y = prediction),
              inherit.aes = FALSE) +
  scale_fill_gradient(name = 'Density (RTS)',
                      low = '#CCFF99',
                      high = '#003300',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  new_scale('fill') +
  geom_bin_2d(data = input_data %>%
                filter(rts_class == 'bg'),
              aes(x = ndvi, y = prediction),
              inherit.aes = FALSE) +
  scale_fill_gradient(name = 'Density (Background)',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery) +
  theme_bw()
```

```{r}
ggplot(input_data,
       aes(x = nir, y = prediction, color = rts_class),
       alpha = 0.1) +
  geom_point() +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(. ~ imagery) +
  scale_color_manual(name = 'Ground Truth',
                     values = c('#CFCECC', '#669900'),
                     labels = c('RTS', 'Background')) +
  theme_bw()
```



## Read in Models from Google Drive

```{python, include = FALSE}
# maxar model
with open('./data/maxar/20230621_022422/params.json', 'r') as f:
  PARAMS = json.load(f)

maxar_model = models.unet_3plus_2d(input_size=PARAMS['model']['input_size'],
                  n_labels=2,
                  filter_num_down=PARAMS['model']['filter_num'],
                  filter_num_skip='auto',
                  filter_num_aggregate='auto',
                  stack_num_down=PARAMS['model']['stack_num_down'],
                  stack_num_up=PARAMS['model']['stack_num_up'],
                  activation=PARAMS['model']['activation'],
                  output_activation=PARAMS['model']['out_activ'],
                  batch_norm=PARAMS['model']['batch_norm'],
                  pool=PARAMS['model']['pooling'],
                  unpool=PARAMS['model']['unpool'],
                  deep_supervision=PARAMS['model']['deep_supervision'],
                  backbone=PARAMS['model']['backbone'],
                  weights=None,
                  freeze_backbone=PARAMS['model']['freeze_backbone'],
                  freeze_batch_norm=PARAMS['model']['freeze_bn'],
                  name='unet3plus')
#import saved model weights
model_path = './data/maxar/20230621_022422/cp-0074-valiou0.695.ckpt'
maxar_model.load_weights(model_path).expect_partial()

# planet model
with open('./data/planet/20230621_190115/params.json', 'r') as f:
  PARAMS = json.load(f)

planet_model = models.unet_3plus_2d(input_size=PARAMS['model']['input_size'],
                  n_labels=2,
                  filter_num_down=PARAMS['model']['filter_num'],
                  filter_num_skip='auto',
                  filter_num_aggregate='auto',
                  stack_num_down=PARAMS['model']['stack_num_down'],
                  stack_num_up=PARAMS['model']['stack_num_up'],
                  activation=PARAMS['model']['activation'],
                  output_activation=PARAMS['model']['out_activ'],
                  batch_norm=PARAMS['model']['batch_norm'],
                  pool=PARAMS['model']['pooling'],
                  unpool=PARAMS['model']['unpool'],
                  deep_supervision=PARAMS['model']['deep_supervision'],
                  backbone=PARAMS['model']['backbone'],
                  weights=None,
                  freeze_backbone=PARAMS['model']['freeze_backbone'],
                  freeze_batch_norm=PARAMS['model']['freeze_bn'],
                  name='unet3plus')
#import saved model weights
model_path = './data/planet/20230621_190115/cp-0085-valiou0.702.ckpt'
planet_model.load_weights(model_path).expect_partial()

# sentinel model
with open('./data/sentinel/20230621_171002/params.json', 'r') as f:
  PARAMS = json.load(f)

planet_model = models.unet_3plus_2d(input_size=PARAMS['model']['input_size'],
                  n_labels=2,
                  filter_num_down=PARAMS['model']['filter_num'],
                  filter_num_skip='auto',
                  filter_num_aggregate='auto',
                  stack_num_down=PARAMS['model']['stack_num_down'],
                  stack_num_up=PARAMS['model']['stack_num_up'],
                  activation=PARAMS['model']['activation'],
                  output_activation=PARAMS['model']['out_activ'],
                  batch_norm=PARAMS['model']['batch_norm'],
                  pool=PARAMS['model']['pooling'],
                  unpool=PARAMS['model']['unpool'],
                  deep_supervision=PARAMS['model']['deep_supervision'],
                  backbone=PARAMS['model']['backbone'],
                  weights=None,
                  freeze_backbone=PARAMS['model']['freeze_backbone'],
                  freeze_batch_norm=PARAMS['model']['freeze_bn'],
                  name='unet3plus')
#import saved model weights
model_path = './data/sentinel/20230621_171002/cp-0081-valiou0.659.ckpt'
planet_model.load_weights(model_path).expect_partial()
```
