---
output:
  html_document: default
  pdf_document: default
---

# RTS Model V2 Performance Analysis

## TODO:

-   Figure out how to remove extra influence of multiple RTS within one tile
-   Figure out why my IoU scores don't quite match Yili's
-   Why are there only 69 prediction rasters now?
-   Add confidence intervals to IoU by size smooth lines
-   Get data to investigate why some small RTS are predicted really well

## Load Libraries

```{r, include = FALSE}
library(terra)
library(sf)
library(spData)
library(leaflet)
library(viridis)
library(googledrive)
library(jsonlite)
library(smoothr)
library(emmeans)
library(nlstools)
library(tidyverse)
```

## Prep Google Drive Authentication

```{r, include = FALSE}
drive_auth(email = 'hrodenhizer@woodwellclimate.org')
```

## Define Functions

### make_my_dir

```{r, include = FALSE}
make_my_dir <- function(output_dir) {

  if (!dir.exists(output_dir)){
    dir.create(output_dir, recursive = TRUE)
  }
  
}
```

### rast_from_googledrive

```{r, include = FALSE}
rast_from_googledrive <- function(name, id, drive_resource, directory) {
  current <- as_dribble(id)
  make_my_dir(directory)
  filepath = paste0(directory, name)
  
  if (!file.exists(filepath)) {
    print(filepath)
    dl <- drive_download(
      current,
      path = filepath)
  }
  
  raster <- rast(filepath)
  names(raster) <- c('prediction', 'validation')
  return(raster)
}
```

### json_from_googledrive

```{r, include = FALSE}
json_from_googledrive <- function(name, id, drive_resource, directory) {
  current <- as_dribble(id)
  make_my_dir(directory)
  filepath = paste0(directory, name)
  
  if (!file.exists(filepath)) {
    dl <- drive_download(
      current,
      path = filepath)
  }
  
  json <- fromJSON(txt = filepath)
  return(json)
}
```

### bbox

```{r, include = FALSE}
bbox <- function(prediction) {
  bbox <- prediction[['prediction']] %>%
    ext() %>%
    st_bbox(crs = crs(prediction)) %>%
    st_as_sfc() %>%
    st_as_sf() %>%
    mutate(id = first(str_split(last(str_split(sources(prediction), 
                                               '/')[[1]]), 
                                '\\.')[[1]])) %>%
    rename(bbox_geometry = x)
  
  return(bbox)
  
}
```

### pred_as_poly

```{r, include = FALSE}
pred_as_poly <- function(prediction) {
  layer <- prediction[['prediction']]
  layer[layer >= 0.5] <- 1
  layer[layer < 0.5] <- 0
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = prediction) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'pred_bg',
                                tk_class == 1 ~ 'pred'),
           id = first(str_split(last(str_split(sources(prediction), 
                                               '/')[[1]]), 
                                '\\.')[[1]])) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('pred_geometry')
  if (!('pred_geometry' %in% colnames(poly))) {
    poly <- poly %>%
      mutate(pred_geometry = st_sfc(st_polygon(), crs = crs(prediction))) %>%
    st_set_geometry('pred_geometry')
  }
  
  return(poly)
}
```

### val_as_poly

```{r, include = FALSE}
val_as_poly <- function(prediction) {
  layer <- prediction[['validation']]
  layer <- classify(layer, 
                    matrix(c(0, 0,
                             1, 1),
                           ncol = 2,
                           byrow = TRUE))
  current_id <- first(str_split(last(str_split(sources(prediction), 
                                                            '/')[[1]]), 
                                             '\\.')[[1]])
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = validation) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'val_bg',
                                tk_class == 1 ~ 'val'),
           id = current_id) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('val_geometry')
  
  return(poly)
}
```

### recall_precision

```{r, echo = FALSE}
recall_precision <- function(truth, iou, thresholds) {
  
  df <- tibble(ground_truth = truth,
               iou_score = iou)
  precision <- c()
  recall <- c()
  
  for (threshold in thresholds) {
    pred_class <- if_else(iou >= threshold,
                          'positive',
                          'negative')
    
    df <- df %>%
      mutate(class = case_when(iou_score >= threshold & ground_truth == 1 ~ 'true positive',
                               iou_score >= threshold & ground_truth == 0 ~ 'false positive',
                               iou_score < threshold & ground_truth == 1 ~ 'false negative',
                               iou_score < threshold & ground_truth == 0 ~ 'true negative'))
    
    # precision = count(true positive)/(count(true positive) + count(false positive))
    precision <- c(precision,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false positive')))
                   )
    )
    
    # recall = count(true positive)/(count(true positive) + count(false negative))
    recall <- c(recall,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false negative')))
                   )
    )
    
  }
  
  recall <- c(recall, 0)
  precision <- c(precision, 1)
  
  output <- tibble(recall = recall,
                   precision = precision)
  
  return(output)
  
}
```

### avg_precision

This is the same as Mean Average Precision for a 1 class model. Otherwise, it would be the mean of the average precision for each class.

```{r, echo = FALSE}
avg_precision <- function(recall, precision) {
  
  ap <- sum((recall[1:length(recall) - 1] - recall[2:length(recall)])*precision[1:length(precision) - 1], na.rm = TRUE)
  return(ap)
  
}
```

## Prep Plot Variables

```{r, echo = FALSE}
imagery_labels <- c('Maxar', 'Planet', 'Sentinel-2')
imagery_labeller <- c('Maxar' = 'Maxar', 'Planet' = 'Planet', 'Sentinel-2' = 'Sentinel-2')
imagery_colors <- c('#FFCC00', '#0099AA', '#0000AA')
```

## Load Data

### Polygons

```{r, echo = FALSE}
rts_outlines <- st_read('./data/rts_polygons/rts_polygons_for_Yili_May_2022_v2.shp') %>%
  st_transform(crs = 3413) %>%
  select(id = ID, region, status = Act_or_Gen, code_id, rts_area = Shape_Area, Long)
```

### Maxar GeoTiffs

20230601-161139-04062023 Parameters:

```{r, echo = FALSE}
# json metadata
maxar_metadata <- drive_ls('https://drive.google.com/drive/folders/1TNRSVgLRhKbD-HVeC0HOslkFWzmhJija',
                             pattern = 'json$')
maxar_metadata <- maxar_metadata %>%
  pmap(
    \(name, id, drive_resource, directory) json_from_googledrive(name, id, drive_resource, './data/maxar/predictions-20230601-161139-04062023/')
    )
maxar_metadata %>%
  toJSON() %>%
  minify()
```

```{r, include = FALSE}
maxar_pred_files <- drive_ls('https://drive.google.com/drive/folders/1TNRSVgLRhKbD-HVeC0HOslkFWzmhJija',
                             pattern = 'tif$') %>%
  arrange(name)

maxar_preds <- maxar_pred_files %>%
  pmap(
    \(name, id, drive_resource, directory) rast_from_googledrive(name, id, drive_resource, './data/maxar/predictions-20230601-161139-04062023/')
    )

rm(maxar_pred_files)
```

### Planet GeoTiffs

20230604-211027-p04062023 Parameters:

```{r, echo = FALSE}
# json metadata
planet_metadata <- drive_ls('https://drive.google.com/drive/folders/1b1msmrdHmfSAFKb2fseg3CNb-JFJH6oj',
                             pattern = 'json$')
planet_metadata <- planet_metadata %>%
  pmap(
    \(name, id, drive_resource, directory) json_from_googledrive(name, id, drive_resource, './data/planet/predictions-20230604-211027-p04062023/')
    )
planet_metadata %>%
  toJSON() %>%
  minify()
```

```{r, include = FALSE}
planet_pred_files <- drive_ls('https://drive.google.com/drive/folders/1b1msmrdHmfSAFKb2fseg3CNb-JFJH6oj',
                             pattern = 'tif$') %>%
  arrange(name)

planet_preds <- planet_pred_files %>%
  pmap(
    \(name, id, drive_resource, directory) rast_from_googledrive(name, id, drive_resource, './data/planet/predictions-20230604-211027-p04062023/')
    )

rm(planet_pred_files)
```

### Sentinel GeoTiffs

20220605-000543-p05062023 Parameters:

```{r, echo = FALSE}
# json metadata
sentinel_metadata <- drive_ls('https://drive.google.com/drive/folders/1RfSjwUPFZ2wmLuRt8-AA3XOKgZH2LcLQ',
                             pattern = 'json$')
sentinel_metadata <- sentinel_metadata %>%
  pmap(
    \(name, id, drive_resource, directory) json_from_googledrive(name, id, drive_resource, './data/sentinel2/predictions-20220605-000543-p05062023/')
    )
sentinel_metadata %>%
  toJSON() %>%
  minify()
```

```{r, include = FALSE}
sentinel_pred_files <- drive_ls('https://drive.google.com/drive/folders/1RfSjwUPFZ2wmLuRt8-AA3XOKgZH2LcLQ',
                             pattern = 'tif$') %>%
  arrange(name)

sentinel_preds <- sentinel_pred_files %>%
  pmap(
    \(name, id, drive_resource, directory) rast_from_googledrive(name, id, drive_resource, './data/sentinel2/predictions-20220605-000543-p05062023/')
    )

rm(sentinel_pred_files)
```


## Get Tile Bounding Boxes

```{r, echo = FALSE}
maxar_tiles <- maxar_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Maxar') %>%
  select(id, imagery, bbox_geometry)

planet_tiles <- planet_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Planet') %>%
  select(id, imagery, bbox_geometry)

sentinel_tiles <- sentinel_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Sentinel-2') %>%
  select(id, imagery, bbox_geometry)

tiles <- maxar_tiles %>%
  rbind.data.frame(planet_tiles) %>%
  rbind.data.frame(sentinel_tiles)

rm(maxar_tiles, planet_tiles, sentinel_tiles)
```

```{r, echo = FALSE}
polys <- tiles %>%
  left_join(rts_outlines %>%
              as_tibble() %>%
              rename(rts_geometry = geometry), 
            by = 'id') %>%
  st_as_sf(crs = st_crs(rts_outlines))

rm(tiles)
```


## Convert Predictions to Vector

```{r, echo = FALSE}
maxar_pred_polys <- maxar_preds %>%
  map_dfr(~ pred_as_poly(.x)) %>%
  mutate(imagery = 'Maxar')

planet_pred_polys <- planet_preds %>%
  map_dfr(~ pred_as_poly(.x)) %>%
  mutate(imagery = 'Planet')

sentinel_pred_polys <- sentinel_preds %>%
  map_dfr(~ pred_as_poly(.x)) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Prediction Polygons into `polys` SF Dataframe

```{r, echo = FALSE}
pred_polys <- maxar_pred_polys %>%
  rbind(planet_pred_polys) %>%
  rbind(sentinel_pred_polys)

polys <- polys %>%
  full_join(pred_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_pred_polys, planet_pred_polys, sentinel_pred_polys, pred_polys)
```


## Convert Validation to Vector

```{r, echo = FALSE}
maxar_val_polys <- maxar_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Maxar')

planet_val_polys <- planet_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Planet')

sentinel_val_polys <- sentinel_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Validation Polygons into `polys` SF Dataframe

```{r, echo = FALSE}
val_polys <- maxar_val_polys %>%
  rbind(planet_val_polys) %>%
  rbind(sentinel_val_polys)

polys <- polys %>%
  full_join(val_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_val_polys, planet_val_polys, sentinel_val_polys, val_polys)
```


## Interactive Map of Features

```{r, echo = FALSE}
pal_viridis <- colorFactor("viridis", polys$imagery)

leaflet() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  addPolygons(data = polys %>%
                select(imagery, pred_geometry) %>%
                st_transform(crs = 4326), 
              color = ~ pal_viridis(imagery),
              fill = FALSE,
              weight = 2) %>%
  addLegend(data = polys, 
            pal = pal_viridis, 
            values = ~ imagery) %>%
  addPolygons(data = polys %>%
                select(val_geometry) %>%
                st_transform(crs = 4326), 
              color = 'black',
              fill = FALSE,
              weight = 2)
```

## IoU

### Calculate Intersection and Union

```{r, echo = FALSE}
polys <- polys %>%
  mutate(rts_int_geometry = st_as_sfc(pmap(list(pred_geometry, val_geometry), ~ st_intersection(...)),
                                  crs = crs(polys)),
         rts_uni_geometry = st_as_sfc(pmap(list(pred_geometry, val_geometry), ~ st_union(...)),
                                  crs = crs(polys)),
         bg_int_geometry = st_as_sfc(pmap(list(pred_bg_geometry, val_bg_geometry), ~ st_intersection(...)),
                                  crs = crs(polys)),
         bg_uni_geometry = st_as_sfc(pmap(list(pred_bg_geometry, val_bg_geometry), ~ st_union(...)),
                                  crs = crs(polys)))
```

### Calculate IoU

```{r, echo = FALSE}
polys <- polys %>%
  mutate(rts_iou = as.numeric(st_area(rts_int_geometry)/st_area(rts_uni_geometry)),
         bg_iou = as.numeric(st_area(bg_int_geometry)/st_area(bg_uni_geometry)),
         mean_iou = (rts_iou + bg_iou)/2)
```

```{r, echo = FALSE}
iou <- polys %>%
  as_tibble() %>%
  group_by(imagery) %>%
  summarise(mean_iou = round(mean(mean_iou), 2))
```

`r iou`


```{r, echo = FALSE}
for (i in 1:69) {
  current_data <- polys %>%
    group_by(imagery) %>%
    slice(i)
  current_id <- unique(current_data$id)
  labeller <- function(variable, value){
    return(hospital_names[value])
  }
  print(ggplot(data = current_data) +
          geom_sf(aes(geometry = bbox_geometry),
                  color = 'black',
                  fill = 'transparent') +
          geom_sf(aes(geometry = val_geometry),
                  color = 'black',
                  fill = 'transparent',
                  linewidth = 0.5) +
          geom_sf(aes(geometry = pred_geometry),
                  color = 'red',
                  fill = 'transparent',
                  linewidth = 0.5) +
          facet_grid(.~ imagery + paste('mIoU:', mean_iou)) +
          ggtitle(paste('ID:', current_id)) +
          theme(axis.title = element_blank()) +
          theme_bw()
          )
  
  rm(current_data, current_id, labeller)
  
}
```


## Mean Average Precision

### Recall-Precision Curves

```{r, echo = FALSE}
polys <- polys %>%
  mutate(ground_truth = 1)

thresholds <- seq(0.2, 0.8, by = 0.1)

maxar_rts_rec_pre <- recall_precision(filter(polys, imagery == 'Maxar')$ground_truth, 
                           filter(polys, imagery == 'Maxar')$rts_iou, 
                           thresholds)

planet_rts_rec_pre <- recall_precision(filter(polys, imagery == 'Planet')$ground_truth, 
                           filter(polys, imagery == 'Planet')$rts_iou, 
                           thresholds)

sentinel_rts_rec_pre <- recall_precision(filter(polys, imagery == 'Sentinel-2')$ground_truth, 
                           filter(polys, imagery == 'Sentinel-2')$rts_iou, 
                           thresholds)

rts_rec_pre <- maxar_rts_rec_pre %>%
  mutate(imagery = 'Maxar') %>%
  rbind.data.frame(planet_rts_rec_pre %>%
                     mutate(imagery = 'Planet')) %>%
  rbind.data.frame(sentinel_rts_rec_pre %>%
                     mutate(imagery = 'Sentinel-2'))


maxar_bg_rec_pre <- recall_precision(filter(polys, imagery == 'Maxar')$ground_truth, 
                           filter(polys, imagery == 'Maxar')$bg_iou, 
                           thresholds)

planet_bg_rec_pre <- recall_precision(filter(polys, imagery == 'Planet')$ground_truth, 
                           filter(polys, imagery == 'Planet')$bg_iou, 
                           thresholds)

sentinel_bg_rec_pre <- recall_precision(filter(polys, imagery == 'Sentinel-2')$ground_truth, 
                           filter(polys, imagery == 'Sentinel-2')$bg_iou, 
                           thresholds)

bg_rec_pre <- maxar_bg_rec_pre %>%
  mutate(imagery = 'Maxar') %>%
  rbind.data.frame(planet_bg_rec_pre %>%
                     mutate(imagery = 'Planet')) %>%
  rbind.data.frame(sentinel_bg_rec_pre %>%
                     mutate(imagery = 'Sentinel-2'))

rec_pre <- rts_rec_pre %>%
  mutate(class = 'rts') %>%
  rbind.data.frame(bg_rec_pre %>%
                     mutate(class = 'bg'))

rm(maxar_rts_rec_pre, planet_rts_rec_pre, sentinel_rts_rec_pre,
   maxar_bg_rec_pre, planet_bg_rec_pre, sentinel_bg_rec_pre,
   rts_rec_pre, bg_rec_pre)
```

### MAP

```{r, echo = FALSE}
avg_pre <- rec_pre %>%
  group_by(imagery, class) %>%
  summarise(avg_pre = avg_precision(recall, precision))

mean_avg_pre <- avg_pre %>%
  group_by(imagery) %>%
  summarise(map = mean(avg_pre)) %>%
  mutate(x_loc = rep(0, 3),
         y_loc = seq(0.2, 0, length.out = 3),
         map_label = paste(imagery, 'MAP =', round(map, 2)))
```

### Plot

Precision measures false positives. Recall measures false negatives.

```{r, echo = FALSE}
arrow_data <- tibble(x = c(0.5, -0.28),
                     xend = c(1, -0.28),
                     y = c(-0.24, 0.5),
                     yend = c(-0.24, 1),
                     imagery = rep('Maxar', 2),
                     class = rep('rts', 2))
label_data <- tibble(x = c(0, -0.28),
                     y = c(-0.24, 0),
                     label = c('Fewer False Negatives    ',
                               'Fewer False Positives    '),
                     angle = c(0, 90),
                     imagery = rep('Maxar', 2),
                     class = rep('rts', 2))

rec_pre_plot <- ggplot(rec_pre,
                       aes(x = recall, y = precision, color = imagery, linetype = class)) +
  geom_line() +
  geom_text(data = mean_avg_pre,
            aes(x = x_loc, y = y_loc, label = map_label),
            inherit.aes = FALSE,
            hjust = 0,
            vjust = 0) +
  geom_segment(data = arrow_data,
               aes(x = x, y = y,
                   xend = xend, yend = yend),
               inherit.aes = FALSE,
               arrow = arrow(type = 'closed', length = unit(0.02, 'npc'))) +
  geom_text(data = label_data,
            aes(x = x, y = y, label = label, angle = angle),
            inherit.aes = FALSE,
            size = 3.5,
            hjust = 0,
            vjust = 0.4,
            color = 'black') +
  scale_x_continuous(name = 'Recall') +
  scale_y_continuous(name = 'Precision') +
  scale_color_manual(labels = imagery_labels,
                     values = imagery_colors) +
  scale_linetype_manual(labels = c('Background', 'RTS'),
                        values = c('dashed', 'solid')) +
  # facet_grid(. ~ imagery) +
  coord_fixed(xlim = c(0, 1),
                  ylim = c(0, 1),
                  clip = 'off') +
  theme_bw() +
  theme(legend.title = element_blank(),
        plot.margin = margin(t = 5.5, r = 5.5, b = 30, l = 30, unit = 'pt'))
rec_pre_plot
```

## Performance by Feature Size

### Calculate Area

```{r, echo = FALSE}
polys <- polys %>%
  mutate(rts_area = round(as.numeric(st_area(val_geometry)), 2),
         rts_area_class = round(rts_area, -2))

poly_size_summary <- polys %>%
  group_by(imagery, rts_area_class) %>%
  summarise(iou_mean = mean(mean_iou),
            iou_se = sd(mean_iou)/sqrt(n()))
```

### Size Distribution by Region

```{r}
sf_use_s2(FALSE)
arctic_box <- tibble(lon = c(-180,180,180,-180,-180),
                    lat = c(90,90,50,50,90)) %>%
  st_as_sf(coords = c("lon","lat"),
           crs = "EPSG:4326") %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON") %>% 
  smoothr::densify(max_distance = 1)

world_north <- world %>%
  st_crop(arctic_box) %>%
  st_transform(crs = st_crs(rts_outlines)) %>%
  select(name_long, continent, region_un, subregion)

world_north_buffer <- world_north %>%
  st_buffer(50000)

if (!('name_long' %in% colnames(polys))) {
  
  polys <- polys %>%
  st_join(world_north_buffer)
  
}

polys <- polys %>%
  mutate(yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
                        TRUE ~ 'Other'))
# 
# rts_outlines <- rts_outlines %>%
#   mutate(yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
#                         TRUE ~ 'Other'))
# 
# ggplot() +
#   geom_sf(data = world_north, fill = 'transparent') +
#   geom_sf(data = rts_outlines,
#           aes(color = yg),
#           linewidth = 1)
```

```{r}
ggplot(polys, aes(x = rts_area, fill = yg)) +
  geom_histogram(position = position_dodge(), bins = 11) +
  scale_fill_manual(values = c('gray50', 'gray20')) +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'Count') +
  theme_bw() +
  theme(legend.title = element_blank())
```

```{r}
rts_summaries <- polys %>%
  as_tibble() %>%
  group_by(yg) %>%
  summarise(mean_size = mean(rts_area),
            min_size = min(rts_area),
            max_size = max(rts_area),
            median_size = median(rts_area))
rts_summaries

ggplot(polys, aes(x = rts_area, fill = yg)) +
  geom_histogram(position = position_dodge(), bins = 15) +
  scale_fill_manual(labels = c('Other', 'YG'),
                     values = c('gray50', 'gray20')) +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'Count') +
  theme_bw() +
  theme(legend.title = element_blank())
```

### Plot

Raw IoU Scores:

This is complicated by the fact that the rts_area column is calculated from the raster validation layer, which may contain several RTS features within one tile. Use rts_area (from the original RTS delineation), instead.

Run `nls` models and bootstrap parameters

```{r, echo = FALSE}
# maxar_iou_nls <- nls(mean_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Maxar'))
# 
# maxar_iou_boot <- nlsBoot(maxar_iou_nls, 500000)
# saveRDS(maxar_iou_nls, './data/models/maxar_iou_nls.RData')
# saveRDS(maxar_iou_boot, './data/models/maxar_iou_boot.RData')

maxar_iou_nls <- readRDS('./data/models/maxar_iou_nls.RData')
maxar_iou_boot <- readRDS('./data/models/maxar_iou_boot.RData')
```

```{r, echo = FALSE}
# planet_iou_nls <- nls(mean_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Planet'))
# 
# planet_iou_boot <- nlsBoot(planet_iou_nls, 500000)
# saveRDS(planet_iou_nls, './data/models/planet_iou_nls.RData')
# saveRDS(planet_iou_boot, './data/models/planet_iou_boot.RData')

planet_iou_nls <- readRDS('./data/models/planet_iou_nls.RData')
planet_iou_boot <- readRDS('./data/models/planet_iou_boot.RData')
```

```{r, echo = FALSE}
# sentinel_iou_nls <- nls(mean_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Sentinel-2'))
# 
# sentinel_iou_boot <- nlsBoot(sentinel_iou_nls, 500000)
# saveRDS(sentinel_iou_nls, './data/models/sentinel_iou_nls.RData')
# saveRDS(sentinel_iou_boot, './data/models/sentinel_iou_boot.RData')

sentinel_iou_nls <- readRDS('./data/models/sentinel_iou_nls.RData')
sentinel_iou_boot <- readRDS('./data/models/sentinel_iou_boot.RData')
```

Bootstrap predictions for plotting the `nls` models

```{r, echo = FALSE}
newdata <- tibble(rts_area = seq(min(polys$rts_area), max(polys$rts_area), length.out = 200))
```

```{r, echo = FALSE}
# maxar_iou_predict <- nlsBootPredict(maxar_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(maxar_iou_predict, './data/models/maxar_iou_predict.RData')

maxar_iou_predict <- readRDS('./data/models/maxar_iou_predict.RData')
maxar_iou_ci <- newdata %>%
  cbind(maxar_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `2.5%`, upr = `97.5%`) %>%
  mutate(predict = predict(maxar_iou_nls, newdata),
         predict_lwr = maxar_iou_boot[["bootCI"]][2, 2] * rts_area / (maxar_iou_boot[["bootCI"]][1, 3] + rts_area),
         predict_upr = maxar_iou_boot[["bootCI"]][2, 3] * rts_area / (maxar_iou_boot[["bootCI"]][1, 2] + rts_area))
```

```{r, echo = FALSE}
# planet_iou_predict <- nlsBootPredict(planet_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(planet_iou_predict, './data/models/planet_iou_predict.RData')

planet_iou_predict <- readRDS('./data/models/planet_iou_predict.RData')
planet_iou_ci <- newdata %>%
  cbind(planet_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `2.5%`, upr = `97.5%`) %>%
  mutate(predict = predict(planet_iou_nls, newdata),
         predict_lwr = predict - (upr - lwr)/2,
         predict_upr = predict + (upr - lwr)/2,
         predict_lwr = planet_iou_boot[["bootCI"]][2, 2] * rts_area / (planet_iou_boot[["bootCI"]][1, 3] + rts_area),
         predict_upr = planet_iou_boot[["bootCI"]][2, 3] * rts_area / (planet_iou_boot[["bootCI"]][1, 2] + rts_area))
```

```{r, echo = FALSE}
# sentinel_iou_predict <- nlsBootPredict(sentinel_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(sentinel_iou_predict, './data/models/sentinel_iou_predict.RData')

sentinel_iou_predict <- readRDS('./data/models/sentinel_iou_predict.RData')
sentinel_iou_ci <- newdata %>%
  cbind(sentinel_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `2.5%`, upr = `97.5%`) %>%
  mutate(predict = predict(sentinel_iou_nls, newdata),
         predict_lwr = predict - (upr - lwr)/2,
         predict_upr = predict + (upr - lwr)/2,
         predict_lwr = sentinel_iou_boot[["bootCI"]][2, 2] * rts_area / (sentinel_iou_boot[["bootCI"]][1, 3] + rts_area),
         predict_upr = sentinel_iou_boot[["bootCI"]][2, 3] * rts_area / (sentinel_iou_boot[["bootCI"]][1, 2] + rts_area))
```

Plot the Size/Performance plot

```{r, echo = FALSE}
iou_ci <- maxar_iou_ci %>%
  mutate(imagery = 'Maxar') %>%
  rbind(planet_iou_ci %>%
          mutate(imagery = 'Planet')) %>%
  rbind(sentinel_iou_ci %>%
          mutate(imagery = 'Sentinel-2'))

rm(maxar_iou_nls, maxar_iou_boot, maxar_iou_predict, maxar_iou_ci,
   planet_iou_nls, planet_iou_boot, planet_iou_predict, planet_iou_ci,
   sentinel_iou_nls, sentinel_iou_boot, sentinel_iou_predict, sentinel_iou_ci)
```

```{r, echo = FALSE}
ggplot(polys, aes(x = rts_area, y = mean_iou, color = imagery)) +
  geom_point(size = 1) +
  # geom_smooth(method="nls",
  #             method.args = list(formula = y ~ Vmax * x / (Km + x),
  #                                start = list(Km = 50, Vmax = 2)),
  #             data = polys,
  #             se = FALSE,
  #             aes(color = imagery),
  #             linetype = 'dashed') +
  geom_ribbon(data = iou_ci,
            aes(x = rts_area, ymin = predict_lwr, ymax = predict_upr, group = imagery),
            alpha = 0.2,
            inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = predict, color = imagery),
            inherit.aes = FALSE) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels) +
  theme_bw() +
  theme(legend.title = element_blank())
```


## Active vs. General RTS Performance

I need to figure out how to deal with polygons that are very close together and show up in the same tile, otherwise this join results in duplicates.

```{r, echo = FALSE}
iou_by_rts_status <- polys %>%
  as_tibble() %>%
  group_by(imagery, status) %>%
  summarise(mean_iou = mean(mean_iou))
```

```{r, echo = FALSE}
rts_status_lm <- lm(mean_iou ~ imagery * status,
                             data = polys)
rts_status_contrasts <- emmeans(rts_status_lm,
        pairwise ~ status | imagery,
        adjust = 'tukey')
rts_status_contrasts
rts_status_pvalues <- tibble(
  imagery = summary(rts_status_contrasts)$contrasts$imagery,
  p_val = summary(rts_status_contrasts)$contrasts$p.value,
  x_pos = rep(1.5, 3),
  star_y_pos = rep(0.9, 3),
  label_y_pos = rep(0.95, 3)
) %>%
  mutate(p_label = paste0('p-value = ', round(p_val, 3)),
         star_label = case_when(p_val > 0.05 ~ '',
                                p_val > 0.01 ~ '*',
                                p_val > 0.001 ~ '**',
                                p_val > 0.0001 ~ '***',
                                TRUE ~ '****'))
rts_status_pvalues
```

### Plot

It is possible to get rid of the inner panel borders, if I decide that looks better: <https://stackoverflow.com/questions/46220242/ggplot2-outside-panel-border-when-using-facet>

```{r, echo = FALSE}
ggplot(polys, 
       aes(x = status, 
           y = mean_iou, 
           group = interaction(imagery, status))) +
  geom_point(position = position_jitterdodge(seed = 1, 
                                             dodge.width = 0.9, 
                                             jitter.width = 0.5),
             aes(color = imagery),
             size = 1,
             alpha = 0.1) +
  geom_violin(aes(color = imagery),
              fill = 'gray60',
              linewidth = 0.75,
              alpha = 0.4,
              draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_text(data = rts_status_pvalues,
            aes(x = x_pos, y = star_y_pos, label = star_label),
            inherit.aes = FALSE) +
  # geom_text(data = rts_status_pvalues,
  #           aes(x = x_pos, y = label_y_pos, label = p_label),
  #           inherit.aes = FALSE) +
  scale_y_continuous(name = 'IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels,
                     guide = 'none') +
  facet_wrap(~ imagery, 
             strip.position = 'bottom', 
             scales = 'free_x',
             labeller = labeller(imagery = imagery_labeller)) +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank(),
        panel.spacing = unit(0, "lines"), 
        strip.background = element_blank(),
        strip.placement = "outside")
```

```{r, echo = FALSE}
poly_status_size_summary <- polys %>%
  group_by(imagery, status, rts_area_class) %>%
  summarise(iou_mean = mean(mean_iou),
            iou_se = sd(mean_iou)/sqrt(n()))
```

```{r, echo = FALSE}
ggplot(poly_status_size_summary, 
       aes(x = rts_area_class, y = iou_mean, color = imagery)) +
  geom_point(size = 2, aes(shape = status)) +
  # geom_errorbar(aes(ymin = iou_mean - iou_se, ymax = iou_mean + iou_se)) +
  # geom_smooth(method = 'gam', formula = y ~ s(x, bs = "cs"),
  #             aes(linetype = status)) +
  geom_smooth(method="nls",
              method.args = list(formula = y ~ Vmax * x / (Km + x),
                                 start = list(Km = 50, Vmax = 2)),
              data = poly_status_size_summary,
              se = FALSE,
              aes(color = imagery, linetype = status)) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels) +
  scale_fill_manual(values = imagery_colors,
                     labels = imagery_labels) +
  scale_shape_manual(values = c(16, 1)) +
  facet_grid(imagery ~ .) +
  theme_bw() +
  theme(legend.title = element_blank()) + 
  coord_cartesian(ylim = c(0, 1)) 
```


## Small RTS with High IoU/Large RTS with Low IoU

Currently using mean values to filter based on size and IoU. Could use the confidence intervals of a non-linear fit instead?

```{r, echo = FALSE}
polys %>%
  as_tibble() %>%
  summarise(mean_size = mean(rts_area),
            min_size = min(rts_area),
            max_size = max(rts_area),
            median_size = median(rts_area),
            sd_size = sd(rts_area))

ggplot(polys, aes(x = rts_area)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = mean(polys$rts_area)) +
  geom_vline(xintercept = median(polys$rts_area), linetype = 'dashed')

polys <- polys %>%
  mutate(size_class = case_when(rts_area <= mean(rts_area) ~ 'Small RTS',
                               rts_area > mean(rts_area) ~ 'Other'),)

rts_size_performance_summary <- polys %>%
  as_tibble() %>%
  group_by(size_class) %>%
  summarise(iou_mean = mean(mean_iou),
            iou_sd = sd(mean_iou),
            iou_median = median(mean_iou),
            iou_min = min(mean_iou),
            iou_max = max(mean_iou))

polys <- polys %>%
  mutate(expected_performance = case_when(
    size_class == 'Small RTS' & mean_iou > filter(rts_size_performance_summary, size_class == 'Other')$iou_mean ~ 'High',
     size_class == 'Other' & mean_iou < filter(rts_size_performance_summary, size_class == 'Small RTS')$iou_mean ~ 'Low',
    TRUE ~ 'Expected'))

ggplot(polys %>%
         filter(size_class == 'Small RTS'), 
       aes(x = size_class, y = mean_iou)) +
  geom_violin()

ggplot(polys %>%
         filter(size_class == 'Small RTS'), 
       aes(x = mean_iou, fill = expected_performance)) +
  geom_histogram(bins = 50)

ggplot(polys, aes(x = rts_area, y = mean_iou, color = expected_performance, shape = imagery)) +
  geom_point(size = 1) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'IoU') +
  theme_bw() +
  theme(legend.title = element_blank()) + 
  coord_cartesian(ylim = c(0, 1))
```

