---
output:
  html_document: default
  pdf_document: default
---

# RTS Model Imagery Performance Analysis

## TODO:

-   Figure out why some features of interest seem to only be half of the RTS (is this a general vs. active issue?) (4a, 4e, 4f, 67, 68)
-   Calculate size needed to exceed IoU of 0.5 for each imagery type
-   Add general and active IoU's to table
-   Start picking figures to include in manuscript!
-   Figure out why my IoU scores don't quite match Yili's. Removing scores for missing RTS gets close on most models, but is still pretty far off for the Maxar (0-1) model.

## Set-Up
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

## Load Libraries

```{r, include = FALSE}
library(reticulate)
library(terra)
library(sf)
library(lwgeom)
library(spData)
library(leaflet)
library(viridis)
library(googledrive)
library(jsonlite)
library(smoothr)
library(tidymodels)
library(emmeans)
library(nlstools)
library(Ryacas)
library(ggnewscale)
library(egg)
library(ggsignif)
library(ggfortify)
library(plotly)
library(tidyverse)
theme_set(theme_bw())
```

## Prep Google Drive Authentication

```{r, include = FALSE}
drive_auth(email = 'hrodenhizer@woodwellclimate.org')
```


## Define Functions

### assign_conf_stars

```{r, include = FALSE}
assign_conf_stars <- function(x) {
  case_when(x <= 0.0001 ~ '****',
            x <= 0.001 ~ '***',
            x <= 0.01 ~ '**',
            x <= 0.05 ~ '*',
            x <= 0.1 ~ '.',
            x > 0.1 ~ '')
}
  
```

### avg_precision

```{r, include = FALSE}
avg_precision <- function(recall, precision) {
  
  ap <- sum((recall[1:length(recall) - 1] - recall[2:length(recall)])*precision[1:length(precision) - 1], na.rm = TRUE)
  return(ap)
  
}
```

### bbox

```{r, include = FALSE}
bbox <- function(prediction) {
  bbox <- prediction[['prediction']] %>%
    ext() %>%
    st_bbox(crs = crs(prediction)) %>%
    st_as_sfc() %>%
    st_as_sf() %>%
    mutate(id = get_rast_id(prediction)) %>%
    rename(bbox_geometry = x)
  
  return(bbox)
  
}
```

### calc_rts_threshold

```{r}
calc_rts_threshold <- function(prediction, thresholds) {
  
  mean_iou <- c()
  
  for (threshold in thresholds) {
    
    # classify the prediction
    prediction[['pred_class']] <- classify(
      prediction[['prediction']],
      matrix(c(0, threshold, 0,
               threshold, 1, 1),
             byrow = TRUE,
             ncol = 3),
      right = FALSE
    )
    
    # calculate ground truth classes
    prediction[['zones']] <- prediction[['pred_class']] + prediction[['validation']]
    prediction[['area']] <- cellSize(prediction[['zones']])
    
    # calculate zonal stats
    areas <- zonal(prediction[['area']],
                   prediction[['zones']],
                   fun = 'sum')
    
    # calculate mean IoU
    rts_iou <- ifelse(is.na(areas$area[3]),
                      0,
                      areas$area[3]/(areas$area[3] + areas$area[2]))
    bg_iou <- areas$area[1]/(areas$area[1] + areas$area[2])
    mean_iou <- c(mean_iou, mean(c(rts_iou, bg_iou)))
    
    
  }
  
  output <- tibble(
    id = get_rast_id(prediction),
    threshold = thresholds,
    mean_iou = mean_iou
  )
  
  return(output)
  
}
```

### eval_expression

```{r, include = FALSE}
eval_expression <- function(expression, x) {
  return(eval(expression))
}
```

### feature_mask

```{r}
feature_mask <- function(validation, polys) {
  
  # get validation layer (all RTS features within the tile)
  val <- validation[['RTSlabel']]
  
  # get polygon ID associated with validation layer
  pid <- get_rast_id(val)
  
  # get the outline of the polygon of interest
  tgt <- polys %>%
    st_set_geometry('rts_geometry') %>%
    filter(id == pid) %>%
    rasterize(val, touches = TRUE)
  
  # calculate distance from validation polygons
  tgt_dist <- distance(tgt)
  val_dist <- distance(val)
  
  # in a few cases, the tgt_dist polygon might be slightly smaller than the val_dist raster. In this case, expand the tgt raster and re-calculate the distance
  tgt[is.na(tgt) & val == 1 & tgt_dist <= res(tgt_dist)[1]*2] <- 1
  tgt_dist <- distance(tgt)
  
  # create a mask that only keeps cells where the euclidean distance from the polygon of interest is smaller than the euclidean distance from all RTS features that occur within the tile
  mask <- tgt
  mask[tgt_dist <= val_dist] <- 1
  
  return(mask)
}
```

### filter_input_data

```{r}
filter_input_data <- function(input_list, ids) {
  input_filtered <- list()
  input_ids <- c()
  idx <- 0
  for (input in input_list) {
    input_id <- get_rast_id(input)
    if (input_id %in% ids) {
      idx <- idx + 1
      input_ids <- c(input_ids, input_id)
      input_filtered[[idx]] <- input
    }
    
  }
  
  input_ordered <- list()
  idx <- 0
  for (id in ids) {
    
    idx <- idx + 1
    input_ordered[[idx]] <- input_filtered[[which(input_ids == id)]]
  }
  
  return(input_ordered)
  
}
```

### get_rast_id

```{r, include = FALSE}
get_rast_id <- function(rast) {
  id <- first(str_split(last(str_split(sources(rast), 
                                       '/')[[1]]), 
                        '\\.')[[1]])
  return(id)
}
```

### googledrive_download

```{r, include = FALSE}
googledrive_download <- function(name, id, drive_resource, directory) {
  current <- as_dribble(id)
  make_my_dir(directory)
  filepath = paste0(directory, '/', name)
  
  if (!file.exists(filepath)) {
    print(filepath)
    dl <- drive_download(
      current,
      path = filepath)
  }

}
```

### input_as_df

```{r, include = FALSE}
input_as_df <- function(input, pred) {
  
  input[['prediction']] <- pred[['prediction']]
  
  # unify layer names
  names(input) <- c('r', 'g', 'b', 'ndvi', 'elev', 'sr', 'nir', 'ndwi', 'rts_class', 'prediction')
  
  # get polygon ID
  current_id <- get_rast_id(input)
  
  # add stretched rgb
  input_stretch <- stretch(subset(input, 1:3),
                          minv = 0,
                          maxv = 1,
                          minq = 0.01,
                          maxq = 1)
  names(input_stretch) <- c('r_stretch', 'g_stretch', 'b_stretch')
  
  input <- c(input, input_stretch)
  
  # convert to dataframe
  df <- input %>%
    as.data.frame(xy = TRUE) %>%
    mutate(id = current_id,
           rts_class = factor(
             case_when(is.na(rts_class) ~ 'bg',
                       rts_class == 1 ~ 'rts'),
             levels = c('rts', 'bg')
           ),
           r = r/max(r, na.rm = TRUE),
           g = g/max(g, na.rm = TRUE),
           b = b/max(b, na.rm = TRUE),
           lum = 0.299*r + 0.587*g + 0.114*b, # lum equation from: https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color
           nir = nir/max(nir, na.rm = TRUE)) %>%
    filter(!(is.na(r_stretch) | is.na(g_stretch) | is.na(b_stretch))) %>%
    mutate(
      color_hex = factor(rgb(r_stretch, g_stretch, b_stretch, maxColorValue = 1))
    )
  return(df)
  
}
```

### import_pred

```{r}
import_pred <- function(filepath) {
  raster <- rast(filepath)
  names(raster) <- c('prediction', 'validation')
  return(raster)
}
```

### lm_contrasts_pq

```{r}
lm_contrasts_pq <- function(model) {
  contrasts <- as_tibble(emmeans(model$fit,
                                 pairwise ~ pq_ci,
                                 adjust = 'dunnettx')$contrasts) %>%
    mutate(star_label = assign_conf_stars(p.value)) %>%
    select(contrast, estimate, se = SE, p_value = p.value, star_label)
}
```

### lm_pq

```{r}
lm_pq <- function(df) {
  model <- linear_reg() %>%
    fit(value ~ pq_ci, 
        data = df)
  return(model)
}
```

### lm_summary

```{r}
lm_summary <- function(model) {
  lm_output <- tidy(model) %>%
    rename_with(~ str_replace_all(., '\\.', '_'))
  return(lm_output)
}
```

### make_my_dir

```{r, include = FALSE}
make_my_dir <- function(output_dir) {

  if (!dir.exists(output_dir)){
    dir.create(output_dir, recursive = TRUE)
  }
  
}
```

### mask_as_df

```{r}
mask_as_df <- function(mask, pid) {
  st_as_sf(as.polygons(mask, values = FALSE)) %>%
           mutate(id = pid)
}
```

### my_nlsBootPredict

```{r}
my_nlsBootPredict <- function (nlsBoot, newdata, 
                               interval = c("confidence", "prediction")) 
{
  if (!inherits(nlsBoot, "nlsBoot"))
    stop("Use only with 'nlsBoot' objects")
  if (missing(newdata))
  {
    newdata <- get(as.character(nlsBoot$nls$data))
  }
  nlsformula <- formula(nlsBoot$nls)
  nlsresid <- resid(nlsBoot$nls)
  param <- nlsBoot$coefboot
  bootparam <- nlsBoot$coefboot
  niter <- length(nlsBoot$rse)
  
  "formula2function"<-function(formu){
    arg1		<- all.vars(formu)
    arg2		<- vector("list",length(arg1))
    names(arg2)	<- arg1
    Args		<- do.call("alist",arg2)
    fmodele		<- as.function(c(Args,formu))
    return(fmodele)
  }
  f1 <- formula2function(formula(nlsformula)[[3]])
  vardep <- all.vars(nlsformula[[2]])
  varindep <- intersect(all.vars(nlsformula[[3]]), colnames(newdata))
  
  ## vector of mean predictions on newdata with one bootstrap sample  
  one.mean.pred <- function(i)
  {
    do.call(f1, as.list(c(param[i,], newdata[varindep])))
  }
  boot.mean.pred <- sapply(1:niter, one.mean.pred)
  
  if (interval == "confidence")
  {
    recap.boot.mean.pred <- t(apply(boot.mean.pred, 1, 
                                    quantile, c(.5, .25, .75))) 
    colnames(recap.boot.mean.pred) <- c("Median", "25%", "75%")
    return(recap.boot.mean.pred)
  } else
  {
    ## vector of individual predictions on newdata with one bootstrap sample
    one.indiv.pred <- function(i)
    {
      boot.mean.pred[, i] + sample(scale(nlsresid, scale=FALSE), 
                                   size = nrow(newdata), replace=TRUE)
    }
    boot.indiv.pred <- sapply(1:niter, one.indiv.pred)
    recap.boot.indiv.pred <- t(apply(boot.indiv.pred, 1, 
                                     quantile, c(.5, .25, .75))) 
    colnames(recap.boot.indiv.pred) <- c("Median", "25%", "75%")
    return(recap.boot.indiv.pred)
  }
}
```

### plot_prediction

```{r}
plot_prediction <- function(pid) {
  
  # get polygon data
  current_data <- polys %>%
    filter(id == pid) %>%
    select(imagery, id, rts_iou, pq_ci, pq_ci_size, bbox_geometry, 
           mask_geometry, rts_geometry, val_geometry, pred_geometry)

  # prep RGB data
  current_rgb <- input_data %>%
    filter(id == pid) %>%
    full_join(current_data %>%
                select(id, imagery, rts_iou),
              by = c('imagery', 'id', 'rts_iou'))

  print(
    ggplot(data = current_data) +
      geom_raster(data = current_rgb,
                  aes(x = x, y = y, fill = color_hex),
                  inherit.aes = FALSE) +
      scale_fill_manual(breaks = levels(input_data$color_hex),
                        values = levels(input_data$color_hex),
                        guide = 'none') +
      geom_sf(aes(geometry = bbox_geometry),
              color = 'black',
              fill = 'transparent') +
      geom_sf(aes(geometry = val_geometry,
              color = 'Validation'),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(name = '',
                         values = c('gray90')) +
      # new_scale('color') +
      # geom_sf(aes(geometry = pred_geometry,
      #         color = pq_ci_size),
      #         fill = 'transparent',
      #         linewidth = 0.5) +
      # scale_color_manual(name = 'Prediction\n(Quality)',
      #                    breaks = pq_labels,
      #                    labels = pq_labels,
      #                    values = pq_colors,
      #                    drop = FALSE) +
      new_scale('color') +
      geom_sf(aes(geometry = rts_geometry,
              color = 'Feature of Interest'),
              fill = 'transparent',
              linewidth = 0.5,
              linetype = 'dashed') +
      scale_color_manual(name = '',
                         values = 'green',
                         drop = FALSE) +
      # new_scale('color') +
      # geom_sf(aes(geometry = mask_geometry,
      #         color = 'AOI'),
      #         fill = 'transparent',
      #         linewidth = 0.5,
      #         linetype = 'dashed') +
      # scale_color_manual(name = '',
      #                    values = 'purple',
      #                    drop = FALSE) +
      facet_grid(paste('ID:', str_remove(id, "^0+")) ~ imagery + paste('RTS IoU:', round(rts_iou, 2))) +
      theme(axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank())
  )

}
```

### plot_zonal_stats

```{r, warning = FALSE}
plot_zonal_stats <- function(x_var, y_var, contrasts, limits) {
  
  predictor_name <- case_when(
    y_var == 'r_mean' ~ "expression('Red')",
    y_var == 'g_mean' ~ "expression('Green')",
    y_var == 'b_mean' ~ "expression('Blue')",
    y_var == 'lum_mean' ~ "expression('Luminance')",
    y_var == 'ndvi_mean' ~ "expression('NDVI')",
    y_var == 'ndwi_mean' ~ "expression('NDWI')",
    y_var == 'elev_mean' ~ "expression('Relative Elevation')",
    y_var == 'sr_mean' ~ "expression('Shaded Relief')",
    y_var == 'r_sd' ~ "expression(sigma ~ 'Red')",
    y_var == 'g_sd' ~ "expression(sigma ~ 'Green')",
    y_var == 'b_sd' ~ "expression(sigma ~ 'Blue')",
    y_var == 'lum_sd' ~ "expression(sigma ~ 'Luminance')",
    y_var == 'ndvi_sd' ~ "expression(sigma ~ 'NDVI')",
    y_var == 'ndwi_sd' ~ "expression(sigma ~ 'NDWI')",
    y_var == 'elev_sd' ~ "expression(sigma ~ 'Relative Elevation')",
    y_var == 'sr_sd' ~ "expression(sigma ~ 'Shaded Relief')"
  )
  
  rts_fig <- ggplot(zonal_stats %>%
                      filter(rts_class == 'RTS'), 
                    aes(x = .data[[x_var]], 
                        y = .data[[y_var]], 
                        color = .data[[x_var]])) +
    geom_boxplot(
      # outlier.shape = NA
      ) +
    geom_signif(data = contrasts %>%
                  filter(variable == y_var & rts_class == 'RTS'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label, group = contrast),
                stat="identity",
                manual = TRUE,
                tip_length = 0.1,
                inherit.aes = FALSE) +
    scale_y_continuous(eval(parse(text = predictor_name))) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme(axis.title.x = element_blank()) +
    coord_cartesian(ylim = limits %>%
                      filter(variable == y_var & rts_class == 'RTS') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())

  delta_fig <- ggplot(zonal_stats %>%
                        filter(rts_class == 'Delta'), 
                      aes(x = .data[[x_var]], 
                          y = .data[[y_var]], 
                          color = .data[[x_var]])) +
    geom_boxplot(
      # outlier.shape = NA
      ) +
    geom_signif(data = contrasts %>%
                  filter(variable == y_var & rts_class == 'Delta'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label, group = contrast),
                stat="identity",
                manual = TRUE,
                inherit.aes = FALSE) +
    scale_x_discrete(name = 'Prediction Quality') +
    scale_y_continuous(eval(parse(text = predictor_name))) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme(axis.title.x = element_blank()) +
    coord_cartesian(ylim = limits %>%
                      filter(variable == y_var & rts_class == 'Delta') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())
  
  bg_fig <- ggplot(zonal_stats %>%
                     filter(rts_class == 'Background'), 
                   aes(x = .data[[x_var]], 
                       y = .data[[y_var]], 
                       color = .data[[x_var]])) +
    geom_boxplot(
      # outlier.shape = NA
      ) +
    geom_signif(data = contrasts %>%
                  filter(variable == y_var & rts_class == 'Background'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label, group = contrast),
                stat="identity",
                manual = TRUE,
                inherit.aes = FALSE) +
    scale_x_discrete(name = 'Prediction Quality') +
    scale_y_continuous(eval(parse(text = predictor_name))) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    coord_cartesian(ylim = limits %>%
                      filter(variable == y_var & rts_class == 'Background') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())

  zonal_stats_fig <- ggarrange(rts_fig +
                                 theme(axis.text.x = element_blank(),
                                       axis.ticks.x = element_blank(),
                                       axis.title.y = element_blank()),
                               delta_fig +
                                 theme(strip.background.x = element_blank(),
                                       strip.text.x = element_blank(),
                                       axis.text.x = element_blank(),
                                       axis.ticks.x = element_blank()),
                               bg_fig +
                                 theme(strip.background.x = element_blank(),
                                       strip.text.x = element_blank(),
                                       axis.ticks.x = element_blank(),
                                       axis.title.y = element_blank()),
                               ncol = 1)
  
  return(zonal_stats_fig)
}
```

### pred_as_poly

```{r, include = FALSE}
pred_as_poly <- function(prediction, threshold = 0.5) {
  layer <- prediction[['prediction']]
  layer[layer >= threshold] <- 1
  layer[layer < threshold] <- 0
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = prediction) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'pred_bg',
                                tk_class == 1 ~ 'pred'),
           id = get_rast_id(prediction)) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('pred_geometry')
  if (!('pred_geometry' %in% colnames(poly))) {
    poly <- poly %>%
      mutate(pred_geometry = st_sfc(st_polygon(), crs = crs(prediction))) %>%
    st_set_geometry('pred_geometry')
  }
  
  return(poly)
}
```

### recall_precision

```{r, include = FALSE}
recall_precision <- function(truth, iou, thresholds) {
  
  df <- tibble(ground_truth = truth,
               iou_score = iou)
  precision <- c()
  recall <- c()
  
  for (threshold in thresholds) {
    pred_class <- if_else(iou >= threshold,
                          'positive',
                          'negative')
    
    df <- df %>%
      mutate(class = case_when(iou_score >= threshold & ground_truth == 1 ~ 'true positive',
                               iou_score >= threshold & ground_truth == 0 ~ 'false positive',
                               iou_score < threshold & ground_truth == 1 ~ 'false negative',
                               iou_score < threshold & ground_truth == 0 ~ 'true negative'))
    
    # precision = count(true positive)/(count(true positive) + count(false positive))
    precision <- c(precision,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false positive')))
                   )
    )
    
    # recall = count(true positive)/(count(true positive) + count(false negative))
    recall <- c(recall,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false negative')))
                   )
    )
    
  }
  
  recall <- c(recall, 0)
  precision <- c(precision, 1)
  
  output <- tibble(recall = recall,
                   precision = precision,
                   threshold = threshold)
  
  return(output)
  
}
```

### trim_outliers

```{r, include = FALSE}
trim_outliers <- function(x) {
  x_quant <- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  x_iqr <- IQR(x, na.rm = TRUE)
  x_trim <- x[x <= x_quant['75%'] + x_iqr*1.5 & x >= x_quant['25%'] - x_iqr*1.5]
  return(x_trim)
}
```

### val_as_poly

```{r, include = FALSE}
val_as_poly <- function(prediction) {
  layer <- prediction[['validation']]
  layer <- classify(layer, 
                    matrix(c(0, 0,
                             1, 1),
                           ncol = 2,
                           byrow = TRUE))
  current_id <- get_rast_id(prediction)
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = validation) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'val_bg',
                                tk_class == 1 ~ 'val'),
           id = current_id) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('val_geometry')
  
  return(poly)
}
```

## Prep Plot Variables

```{r}
imagery_labels <- c('Maxar', 'Planet', 'Sentinel-2')
imagery_labeller <- c('Maxar' = 'Maxar', 'Planet' = 'Planet', 'Sentinel-2' = 'Sentinel-2')
imagery_colors <- c('#FFCC00', '#0099AA', '#0000AA')

# prediction quality (pq)
pq_labels <- c('High', 'Expected', 'Low')
pq_colors <- c('#00CCFF', 'gray20', '#CC0000')
```


## Load Data

### Download Files

```{r}
loc_dir <- './data'
gd_dir <- 'data/DATA_V3_GEOTIFFS'
# maxar_pred_dir <- 'MAXAR20230623_161858_p25062023'
maxar_pred_dir <- 'MAXAR20230621_022422_p21062023'
planet_pred_dir <- 'PLANET20230621_190115_p21062023'
sentinel_pred_dir <- 'SENTINEL220230621_171002_p21062023'

gd_pred_folders <- drive_ls(paste0(gd_dir, '/TESTSET_INFERENCE')) %>%
  filter(name ==  maxar_pred_dir |
           name == planet_pred_dir |
           name == sentinel_pred_dir)

gd_maxar_input_folders <- drive_ls(paste0(gd_dir, '/MAXAR')) %>%
  filter(str_detect(name, 'valtest'))
gd_planet_input_folders <- drive_ls(paste0(gd_dir, '/PLANET')) %>%
  filter(str_detect(name, 'valtest'))
gd_sentinel_input_folders<- drive_ls(paste0(gd_dir, '/SENTINEL2')) %>%
  filter(str_detect(name, 'valtest'))
```

```{r}
# check if prediction files have already been downloaded
loc_filepaths <- list.files(loc_dir,
                            full.names = TRUE,
                            recursive = TRUE)

# Maxar
maxar_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(maxar_pred_dir))
]
maxar_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('maxar/(', 
                    gd_maxar_input_folders$name[1], '|', 
                    gd_maxar_input_folders$name[2], ')'))
]

# Planet
planet_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(planet_pred_dir))
]
planet_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('planet/(', 
                    gd_planet_input_folders$name[1], '|', 
                    gd_planet_input_folders$name[2], ')'))
]

# Sentinel
sentinel_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(sentinel_pred_dir))
]
sentinel_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('sentinel/(', 
                    gd_sentinel_input_folders$name[1], '|', 
                    gd_sentinel_input_folders$name[2], ')'))
]
```

```{r}
if (length(maxar_pred_files) == length(planet_pred_files) & 
    length(maxar_pred_files) == length(sentinel_pred_files) & 
    length(maxar_pred_files) > 0) {
  
  print(paste('There are', length(maxar_pred_files), 'prediction tiles.'))
  
} else {
  
  # download Maxar predictions
  maxar_pred_filepath <- paste0(loc_dir, '/maxar/predictions-', maxar_pred_dir)
  maxar_pred_files <- drive_ls(gd_pred_folders %>%
                                 filter(str_detect(name, 'MAXAR')),
                               pattern = 'tif$') %>%
    arrange(name)
  
  maxar_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, maxar_pred_filepath)
    )
  
  maxar_pred_files <- list.files(maxar_pred_filepath,
                                 pattern = 'tif$',
                                 full.names = TRUE)
  
  # download Planet predictions
  planet_pred_filepath <- paste0(loc_dir, '/planet/predictions-', planet_pred_dir)
  planet_pred_files <- drive_ls(gd_pred_folders %>%
                                  filter(str_detect(name, 'PLANET')),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, planet_pred_filepath)
    )
  
  planet_pred_files <- list.files(planet_pred_filepath,
                                  pattern = 'tif$',
                                  full.names = TRUE)
  
  # download Sentinel-2 predictions
  sentinel_pred_filepath <- paste0(loc_dir, '/sentinel/predictions-', sentinel_pred_dir)
  sentinel_pred_files <- drive_ls(gd_pred_folders %>%
                                    filter(str_detect(name, 'SENTINEL2')),
                                  pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, sentinel_pred_filepath)
    )
  
  sentinel_pred_files <- list.files(sentinel_pred_filepath,
                                    pattern = 'tif$',
                                    full.names = TRUE)
  
}

rm(gd_pred_folders)
```

```{r}
if (length(maxar_input_files) == length(planet_input_files) & 
    length(maxar_input_files) == length(sentinel_input_files) &
    length(maxar_input_files > 0)) {
  
  print(paste('There are', length(maxar_input_files), 'input data tiles.'))
  
} else {
  
  # Download Maxar Input Data Layers  
  maxar_input_filepaths <- paste0(loc_dir, '/maxar/', gd_maxar_input_folders$name)
  
  maxar_input_files <- drive_ls(gd_maxar_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  maxar_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, maxar_input_filepaths[1])
    )
  
  maxar_input_files <- drive_ls(gd_maxar_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  maxar_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, maxar_input_filepaths[2])
    )
  
  maxar_input_files <- map(maxar_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  maxar_input_files <- unlist(maxar_input_files)
  
  # Download Planet Input Data Layers  
  planet_input_filepaths <- paste0(loc_dir, '/planet/', gd_planet_input_folders$name)
  
  planet_input_files <- drive_ls(gd_planet_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, planet_input_filepaths[1])
    )
  
  planet_input_files <- drive_ls(gd_planet_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, planet_input_filepaths[2])
    )
  
  planet_input_files <- map(planet_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  planet_input_files <- unlist(planet_input_files)
  
  # Download sentinel Input Data Layers  
  sentinel_input_filepaths <- paste0(loc_dir, '/sentinel/', gd_sentinel_input_folders$name)
  
  sentinel_input_files <- drive_ls(gd_sentinel_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, sentinel_input_filepaths[1])
    )
  
  sentinel_input_files <- drive_ls(gd_sentinel_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, sentinel_input_filepaths[2])
    )
  
  sentinel_input_files <- map(sentinel_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  sentinel_input_files <- unlist(sentinel_input_files)
  
}

rm(gd_maxar_input_folders, gd_planet_input_folders, gd_sentinel_input_folders)
```

### Maxar GeoTiffs

```{r, include = FALSE}
maxar_pred_dir_zscore <- 'MAXAR20230623_161858_p25062023'
maxar_pred_filepath_zscore <- paste0(loc_dir, '/maxar/predictions-', maxar_pred_dir_zscore)
maxar_pred_files_zscore <- list.files(maxar_pred_filepath_zscore,
                                 pattern = 'tif$',
                                 full.names = TRUE)

maxar_preds <- map(maxar_pred_files, ~ import_pred(.x))
maxar_preds_zscore <- map(maxar_pred_files_zscore, ~ import_pred(.x))

rm(maxar_pred_files)
```

```{r, include = FALSE}
pred_ids <- c()
for (pred in maxar_preds) {
  pred_ids <- c(pred_ids, get_rast_id(pred))
}

maxar_input <- map(maxar_input_files, ~ rast(.x))
ids <- map_chr(maxar_input, ~ get_rast_id(.x))
names(maxar_input) <- ids

maxar_input <- filter_input_data(maxar_input, pred_ids)
rm(maxar_input_files)
```


### Planet GeoTiffs

```{r, include = FALSE}
planet_preds <- map(planet_pred_files, ~ import_pred(.x))

rm(planet_pred_files)
```

```{r, include = FALSE}
planet_input <- map(planet_input_files, ~ rast(.x))
ids <- map_chr(planet_input, ~ get_rast_id(.x))
names(planet_input) <- ids

planet_input <- filter_input_data(planet_input, pred_ids)
rm(planet_input_files)
```

### Sentinel GeoTiffs

```{r, include = FALSE}
sentinel_preds <- map(sentinel_pred_files, ~ import_pred(.x))

rm(sentinel_pred_files)
```

```{r, include = FALSE}
sentinel_input <- map(sentinel_input_files, ~ rast(.x))
ids <- map_chr(sentinel_input, ~ get_rast_id(.x))
names(sentinel_input) <- ids

sentinel_input <- filter_input_data(sentinel_input, pred_ids)
rm(sentinel_input_files)
```

### Polygons

```{r}
rts_outlines <- st_read('./data/rts_polygons/rts_polygons_for_Yili_May_2022_v2.shp') %>%
  st_transform(crs = 3413) %>%
  select(id = ID, region, status = Act_or_Gen, code_id, rts_area = Shape_Area, 
         Long) %>%
  mutate(
    rts_shape = as.numeric(4*pi*st_area(geometry)/st_perimeter(geometry)^2) # calculate Polsby-Popper value (shape compactness/roundness)
    )  %>%
  filter(id %in% pred_ids)

rts_outlines_new <- st_read('./data/rts_polygons/rts_polygons_for_Yili_Jan_2023.shp') %>%
  st_transform(crs = 3413) %>%
  select(id = ID, status = Act_or_Gen, code_id, rts_area = Shape_Area, 
         Long) %>%
  mutate(
    rts_shape = as.numeric(4*pi*st_area(geometry)/st_perimeter(geometry)^2)
    )# %>%
  # filter(id %in% pred_ids)
```

```{r}
test <- rts_outlines %>%
  filter(id == "0000000000000000004a")

test2 <- rts_outlines_new %>%
  filter(as.vector(st_intersects(test, sparse = FALSE)))
```

```{r}
walk(
  pred_ids,
  ~ print(ggplot() +
            geom_sf(data = rts_outlines %>%
                      filter(id == .x), 
                    aes(geometry = geometry),
                    color = 'black', fill = 'transparent') +
            geom_sf(data = rts_outlines_new %>%
                      filter(id == .x), 
                    aes(geometry = geometry),
                    color = 'red', fill = 'transparent') +
            ggtitle(paste('ID:', .x)))
  )
```


## Get Tile Bounding Boxes

```{r}
maxar_tiles <- maxar_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Maxar') %>%
  select(id, imagery, bbox_geometry)

planet_tiles <- planet_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Planet') %>%
  select(id, imagery, bbox_geometry)

sentinel_tiles <- sentinel_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Sentinel-2') %>%
  select(id, imagery, bbox_geometry)

tiles <- maxar_tiles %>%
  rbind.data.frame(planet_tiles) %>%
  rbind.data.frame(sentinel_tiles)

rm(maxar_tiles, planet_tiles, sentinel_tiles)
```

```{r}
polys <- tiles %>%
  left_join(rts_outlines %>%
              st_transform(crs = 3413) %>%
              as_tibble() %>%
              rename(rts_geometry = geometry), 
            by = 'id') %>%
  st_as_sf(crs = st_crs(rts_outlines))

rm(tiles)
```


## Convert Predictions to Vector

```{r}
maxar_pred_polys <- maxar_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x
      )
    ) %>%
  mutate(imagery = 'Maxar')

maxar_pred_polys_zscore <- maxar_preds_zscore %>%
  map_dfr(
    ~ pred_as_poly(
      .x
      )
    ) %>%
  mutate(imagery = 'Maxar')

planet_pred_polys <- planet_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x
      )
    ) %>%
  mutate(imagery = 'Planet')

sentinel_pred_polys <- sentinel_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x#, sentinel_rts_threshold
      )
    ) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Prediction Polygons into `polys` SF Dataframe

```{r}
pred_polys <- maxar_pred_polys %>%
  rbind(planet_pred_polys) %>%
  rbind(sentinel_pred_polys)

polys <- polys %>%
  full_join(pred_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_pred_polys, planet_pred_polys, sentinel_pred_polys, pred_polys)
```


## Convert Validation to Vector

```{r}
maxar_val_polys <- maxar_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Maxar')

planet_val_polys <- planet_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Planet')

sentinel_val_polys <- sentinel_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Validation Polygons into `polys` SF Dataframe

```{r}
val_polys <- maxar_val_polys %>%
  rbind(planet_val_polys) %>%
  rbind(sentinel_val_polys)

polys <- polys %>%
  full_join(val_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_val_polys, planet_val_polys, sentinel_val_polys, val_polys)
```


## Create AOI Masks for Tiles

This allows the inclusion of RTS features that are in tiles with multiple features, by masking out areas associated with RTS features that are not the feature of interest

```{r}
maxar_masks <- maxar_input %>%
  map(~ feature_mask(.x, rts_outlines))

planet_masks <- planet_input %>%
          map(~ feature_mask(.x, rts_outlines))

sentinel_masks <- sentinel_input %>%
          map(~ feature_mask(.x, rts_outlines))

masks <- maxar_masks %>%
  map2_dfr(pred_ids, ~ mask_as_df(.x, .y)) %>%
  mutate(imagery = 'Maxar') %>%
  rbind(planet_masks %>%
          map2_dfr(pred_ids, ~ mask_as_df(.x, .y)) %>%
          mutate(imagery = 'Planet')) %>%
  rbind(sentinel_masks %>%
          map2_dfr(pred_ids, ~ mask_as_df(.x, .y)) %>%
          mutate(imagery = 'Sentinel-2'))

masks_df <- pmap(list(maxar_masks, pred_ids),
                 \(a, b) (as.data.frame(a, xy = TRUE) %>%
                            mutate(imagery = 'Maxar',
                                   id = b) %>%
                            select(imagery, id, x, y, mask = layer))) %>%
  list_rbind() %>%
  rbind(pmap(list(planet_masks, pred_ids),
             \(a, b) (as.data.frame(a, xy = TRUE) %>%
                        mutate(imagery = 'Planet',
                               id = b) %>%
                        select(imagery, id, x, y, mask = layer))) %>%
          list_rbind()) %>%
  rbind(pmap(list(sentinel_masks, pred_ids),
             \(a, b) (as.data.frame(a, xy = TRUE) %>%
                        mutate(imagery = 'Sentinel-2',
                               id = b) %>%
                        select(imagery, id, x, y, mask = layer))) %>%
          list_rbind())
```

```{r}
polys <- polys %>%
  left_join(masks %>%
              as_tibble() %>%
              select(imagery, id, mask_geometry = geometry),
            by = c('imagery', 'id')) %>%
  mutate(pred_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                             mask_geometry), 
                                        ~ st_intersection(...)),
                                   crs = crs(polys)),
         pred_bg_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                                 mask_geometry), 
                                            ~ st_intersection(...)),
                                       crs = crs(polys))) %>%
  mutate(val_mask_geometry = st_as_sfc(pmap(list(val_geometry, 
                                                 mask_geometry), 
                                            ~ st_intersection(...)),
                                       crs = crs(polys)),
         val_bg_mask_geometry = st_as_sfc(pmap(list(val_bg_geometry, 
                                                    mask_geometry), 
                                               ~ st_intersection(...)),
                                          crs = crs(polys)))
rm(masks)
```


## Convert Input Data to DF

```{r}
input_data <- pmap(list(x = maxar_input, 
                        y = maxar_preds),
                   \(x, y) input_as_df(x, y)) %>%
  list_rbind() %>%
  mutate(imagery = 'Maxar') %>%
  rbind(
    pmap(list(x = planet_input, 
              y = planet_preds),
         \(x, y) input_as_df(x, y)) %>%
      list_rbind() %>%
      mutate(imagery = 'Planet')
  ) %>%
  rbind(
    pmap(list(x = sentinel_input, 
              y = sentinel_preds),
         \(x, y) input_as_df(x, y)) %>%
      list_rbind() %>%
      mutate(imagery = 'Sentinel-2')
  ) %>%
  select(imagery, id, rts_class, x, y, 
         r, g, b, lum, nir, ndvi, ndwi, elev, sr, 
         r_stretch, g_stretch, b_stretch, color_hex, prediction)
```


## Interactive Map of Features

```{r}
pal_viridis <- colorFactor("viridis", polys$imagery)

leaflet() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  addPolygons(data = polys %>%
                select(imagery, pred_geometry) %>%
                st_transform(crs = 4326), 
              color = ~ pal_viridis(imagery),
              fill = FALSE,
              weight = 2) %>%
  addLegend(data = polys, 
            pal = pal_viridis, 
            values = ~ imagery) %>%
  addPolygons(data = polys %>%
                select(val_geometry) %>%
                st_transform(crs = 4326), 
              color = 'black',
              fill = FALSE,
              weight = 2)
```

## IoU

### Calculate Intersection and Union

```{r}
polys <- polys %>%
  mutate(rts_int_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                                val_mask_geometry), 
                                           ~ st_intersection(...)),
                                  crs = crs(polys)),
         rts_uni_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                                val_mask_geometry), 
                                           ~ st_union(...)),
                                  crs = crs(polys)),
         bg_int_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                               val_bg_mask_geometry), 
                                          ~ st_intersection(...)),
                                  crs = crs(polys)),
         bg_uni_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                               val_bg_mask_geometry), 
                                          ~ st_union(...)),
                                  crs = crs(polys)))
```

### Calculate IoU

IoU (Calculated in Model)

|Imagery (normalization method)|Test IoU|Val IoU|
|:---:|:---:|:---:|
|Maxar (0-1)|0.75|0.69|
|Maxar (z-score)|0.73|0.72|
|Planet (0-1)|0.71|0.70|
|Sentinel-2 (0-1)|0.68|0.66|


```{r}
polys <- polys %>%
  mutate(rts_iou = as.numeric(st_area(rts_int_geometry)/st_area(rts_uni_geometry)),
         bg_iou = as.numeric(st_area(bg_int_geometry)/st_area(bg_uni_geometry)),
         mean_iou = (rts_iou + bg_iou)/2,
         mean_iou_v2 = case_when(
           st_is_empty(pred_geometry) ~ bg_iou,
           TRUE ~ (rts_iou + bg_iou)/2
         ))
```

```{r}
iou <- polys %>%
  as_tibble() %>%
  group_by(imagery) %>%
  summarise(rts_iou = round(mean(rts_iou), 2),
            mean_iou = round(mean(mean_iou), 2),
            mean_iou_v2 = round(mean(mean_iou_v2), 2)) %>%
  select(Imagery = imagery, `RTS IoU` = rts_iou, `Val IoU` = mean_iou, `Val IoU (remove zeros)` = mean_iou_v2)
knitr::kable(iou, caption = 'IoU (Calculated Directly from Predictions)')
```

```{r, fig.width = 4, fig.height = 4}
imagery_performance_summary <- polys %>%
  as_tibble() %>%
  group_by(imagery) %>%
  summarise(rts_iou_mean = mean(rts_iou),
            rts_iou_median = median(rts_iou),
            rts_iou_sd = sd(rts_iou),
            mean_iou_median = median(mean_iou),
            mean_iou_sd = sd(mean_iou))

ggplot(polys,
       aes(x = rts_iou, fill = imagery)) +
  geom_histogram(bins = 15) +
  geom_vline(data = imagery_performance_summary,
             aes(xintercept = rts_iou_median, linetype = 'Median')) +
  geom_vline(data = imagery_performance_summary,
             aes(xintercept = rts_iou_mean, linetype = 'Mean')) +
  # geom_vline(data = imagery_performance_summary,
  #            aes(xintercept = rts_iou_median - rts_iou_sd),
  #            linetype = 'dotted') +
  # geom_vline(data = imagery_performance_summary,
  #            aes(xintercept = rts_iou_median + rts_iou_sd),
  #            linetype = 'dotted') +
  # geom_vline(data = imagery_performance_summary,
  #            aes(xintercept = rts_iou_median + 2*rts_iou_sd),
  #            linetype = 'dotted') +
  scale_x_continuous(name = 'RTS IoU') +
  scale_y_continuous(name = 'Count') +
  scale_fill_manual(values = imagery_colors) +
  scale_linetype_manual(values = c('solid', 'dashed')) +
  facet_grid(imagery ~ .) +
  theme(legend.title = element_blank())

# ggsave('./figures/iou_hist.pdf',
#        height = 4,
#        width = 4)
# ggsave('./figures/iou_hist.jpg',
#        height = 4,
#        width = 4)

knitr::kable(imagery_performance_summary)
```


## Performance by Feature Size

### Size Distribution by Region

```{r}
sf_use_s2(FALSE)
arctic_box <- tibble(lon = c(-180,180,180,-180,-180),
                    lat = c(90,90,50,50,90)) %>%
  st_as_sf(coords = c("lon","lat"),
           crs = "EPSG:4326") %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON") %>% 
  smoothr::densify(max_distance = 1)

world_north <- world %>%
  st_crop(arctic_box) %>%
  st_transform(crs = st_crs(rts_outlines)) %>%
  select(name_long, continent, region_un, subregion)

world_north_buffer <- world_north %>%
  st_buffer(50000)

if (!('name_long' %in% colnames(polys))) {
  
  polys <- polys %>%
  st_join(world_north_buffer)
  
}

polys <- polys %>%
  mutate(yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
                        TRUE ~ 'Other'))
# 
# rts_outlines <- rts_outlines %>%
#   mutate(yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
#                         TRUE ~ 'Other'))
# 
# ggplot() +
#   geom_sf(data = world_north, fill = 'transparent') +
#   geom_sf(data = rts_outlines,
#           aes(color = yg),
#           linewidth = 1)
```

```{r, include = FALSE}
rts_area_hist <- ggplot(polys, aes(x = rts_area, fill = yg)) +
  geom_density(alpha = 0.9) +
  scale_fill_manual(values = c('white', 'black')) +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'Density') +
  theme(legend.title = element_blank())
rts_area_hist

# ggsave('./figures/rts_area_hist.pdf',
#        rts_area_hist,
#        width = 6.5,
#        height = 3)
# ggsave('./figures/rts_area_hist.jpg',
#        rts_area_hist,
#        width = 6.5,
#        height = 3)
```

```{r, include = FALSE}
rts_shape_hist <- ggplot(polys, aes(x = rts_shape, fill = yg)) +
  geom_density(alpha = 0.9) +
  scale_fill_manual(values = c('white', 'black')) +
  scale_x_continuous(name = expression('RTS Shape')) +
  scale_y_continuous(name = 'Density') +
  theme(legend.title = element_blank())
rts_shape_hist

# ggsave('./figures/rts_shape_hist.pdf',
#        rts_shape_hist,
#        width = 6.5,
#        height = 3)
# ggsave('./figures/rts_shape_hist.jpg',
#        rts_shape_hist,
#        width = 6.5,
#        height = 3)
```

```{r, fig.height = 4, fig.width = 6.5}
rts_area_shape_hist <- ggarrange(
  rts_area_hist +
    theme(legend.position = 'none'),
  rts_shape_hist +
    theme(legend.position = 'bottom'),
  ncol = 1,
  nrow = 2
)

# ggsave('./figures/rts_area_shape_hist.pdf',
#        rts_area_shape_hist,
#        width = 6.5,
#        height = 4)
# ggsave('./figures/rts_area_shape_hist.jpg',
#        rts_area_shape_hist,
#        width = 6.5,
#        height = 4)
```

```{r}
rts_summaries <- polys %>%
  as_tibble() %>%
  group_by(yg) %>%
  summarise(mean_size = mean(rts_area),
            min_size = min(rts_area),
            max_size = max(rts_area),
            median_size = median(rts_area))
knitr::kable(rts_summaries)
```

### Plot

Raw IoU Scores:

Run `nls` models and bootstrap parameters

```{r}
# maxar_iou_nls <- nls(rts_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Maxar'))
# 
# maxar_iou_boot <- nlsBoot(maxar_iou_nls, 500000)
# saveRDS(maxar_iou_nls, './data/models/maxar_iou_nls.RData')
# saveRDS(maxar_iou_boot, './data/models/maxar_iou_boot.RData')

maxar_iou_nls <- readRDS('./data/models/maxar_iou_nls.RData')
maxar_iou_boot <- readRDS('./data/models/maxar_iou_boot.RData')
summary(maxar_iou_nls)
```

```{r}
# planet_iou_nls <- nls(rts_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Planet'))
# 
# planet_iou_boot <- nlsBoot(planet_iou_nls, 500000)
# saveRDS(planet_iou_nls, './data/models/planet_iou_nls.RData')
# saveRDS(planet_iou_boot, './data/models/planet_iou_boot.RData')

planet_iou_nls <- readRDS('./data/models/planet_iou_nls.RData')
planet_iou_boot <- readRDS('./data/models/planet_iou_boot.RData')
summary(planet_iou_nls)
```

```{r}
# sentinel_iou_nls <- nls(rts_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Sentinel-2'))
# 
# sentinel_iou_boot <- nlsBoot(sentinel_iou_nls, 500000)
# saveRDS(sentinel_iou_nls, './data/models/sentinel_iou_nls.RData')
# saveRDS(sentinel_iou_boot, './data/models/sentinel_iou_boot.RData')

sentinel_iou_nls <- readRDS('./data/models/sentinel_iou_nls.RData')
sentinel_iou_boot <- readRDS('./data/models/sentinel_iou_boot.RData')
summary(sentinel_iou_nls)
```

Table for nls model summaries

```{r}
rts_iou_summary <- tidy(maxar_iou_nls) %>%
  mutate(Imagery = 'Maxar') %>%
  rbind(tidy(planet_iou_nls) %>%
          mutate(Imagery = 'Planet')) %>%
  rbind(tidy(sentinel_iou_nls) %>%
          mutate(Imagery = 'Sentinel-2')) %>%
  mutate(across(estimate:p.value, ~ round(.x, 3)),
         p.value = case_when(p.value == 0 ~ '<0.001',
                             p.value > 0 ~ as.character(p.value))) %>%
  select(Imagery, Term = term, Estimate = estimate, SE = std.error, 
         `t-statistic` = statistic, `p-value` = p.value)

# write.csv(rts_iou_summary,
#           './tables/iou_size_nls.csv',
#           row.names = FALSE)

knitr::kable(rts_iou_summary)
```

Bootstrap predictions for plotting the `nls` models

```{r}
newdata <- tibble(rts_area = seq(min(polys$rts_area), max(polys$rts_area), length.out = 200))
newdata2 <- tibble(rts_area = c(min(polys$rts_area),
                                seq(ceiling(min(polys$rts_area)/100)*100, 
                                    ceiling(max(polys$rts_area)/100)*100, 
                                    by = 100),
                                max(polys$rts_area)))
```

```{r}
# maxar_iou_predict <- my_nlsBootPredict(maxar_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(maxar_iou_predict, './data/models/maxar_iou_predict.RData')

maxar_iou_predict <- readRDS('./data/models/maxar_iou_predict.RData')
maxar_iou_ci <- newdata %>%
  cbind(maxar_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `25%`, upr = `75%`)
```

```{r}
# planet_iou_predict <- my_nlsBootPredict(planet_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(planet_iou_predict, './data/models/planet_iou_predict.RData')

planet_iou_predict <- readRDS('./data/models/planet_iou_predict.RData')
planet_iou_ci <- newdata %>%
  cbind(planet_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `25%`, upr = `75%`)
```

```{r}
# sentinel_iou_predict <- my_nlsBootPredict(sentinel_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(sentinel_iou_predict, './data/models/sentinel_iou_predict.RData')

sentinel_iou_predict <- readRDS('./data/models/sentinel_iou_predict.RData')
sentinel_iou_ci <- newdata %>%
  cbind(sentinel_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `25%`, upr = `75%`)
```

```{r}
# Add predictions to `polys`
iou_predictions <- rbind(
  my_nlsBootPredict(maxar_iou_boot, 
                    polys %>%
                      as_tibble() %>%
                      filter(imagery == 'Maxar'),
                    interval = 'prediction'),
  my_nlsBootPredict(planet_iou_boot, 
                    polys %>%
                      as_tibble() %>%
                      filter(imagery == 'Planet'),
                    interval = 'prediction'),
  my_nlsBootPredict(sentinel_iou_boot, 
                    polys %>%
                      as_tibble() %>%
                      filter(imagery == 'Sentinel-2'),
                    interval = 'prediction')
  )

polys <- polys %>%
  mutate(
    iou_pred = iou_predictions[, 1],
    iou_pred_lwr = iou_predictions[, 2],
    iou_pred_upr = iou_predictions[, 3]
  )
```

Plot the Size/Performance plot

```{r}
iou_ci <- maxar_iou_ci %>%
  mutate(imagery = 'Maxar') %>%
  rbind(planet_iou_ci %>%
          mutate(imagery = 'Planet')) %>%
  rbind(sentinel_iou_ci %>%
          mutate(imagery = 'Sentinel-2'))

rm(maxar_iou_nls, maxar_iou_ci,
   planet_iou_nls, planet_iou_ci, 
   sentinel_iou_nls, sentinel_iou_ci, 
   newdata, mean_iou_predictions, rts_iou_predictions)
```

```{r}
ggplot(polys, aes(x = rts_area, y = rts_iou, color = imagery)) +
  geom_point(size = 1) +
  geom_ribbon(data = iou_ci,
            aes(x = rts_area, ymin = lwr, ymax = upr, group = imagery),
            alpha = 0.2,
            inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU',
                     limits = c(0, 1)) +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels) +
  theme(legend.title = element_blank())
```


## Active vs. General RTS Performance

```{r}
iou_by_rts_status <- polys %>%
  as_tibble() %>%
  group_by(imagery, status) %>%
  summarise(mean_iou = mean(mean_iou),
            rts_iou = mean(rts_iou))
```

```{r}
rts_status_lm <- lm(rts_iou ~ imagery * status,
                             data = polys)
rts_status_contrasts <- emmeans(rts_status_lm,
        pairwise ~ status | imagery,
        adjust = 'tukey')

rts_status_pvalues <- tibble(
  imagery = summary(rts_status_contrasts)$contrasts$imagery,
  p_val = summary(rts_status_contrasts)$contrasts$p.value,
  x_pos = rep(1.5, 3),
  star_y_pos = rep(0.9, 3),
  label_y_pos = rep(0.95, 3)
) %>%
  mutate(p_label = paste0('p-value = ', round(p_val, 3)),
         star_label = assign_conf_stars(p_val))
knitr::kable(rts_status_pvalues)
```

### Plot

It is possible to get rid of the inner panel borders, if I decide that looks better: <https://stackoverflow.com/questions/46220242/ggplot2-outside-panel-border-when-using-facet>

```{r}
ggplot(polys, 
       aes(x = status, 
           y = rts_iou, 
           group = interaction(imagery, status))) +
  geom_point(position = position_jitterdodge(seed = 1, 
                                             dodge.width = 0.9, 
                                             jitter.width = 0.5),
             aes(color = imagery),
             size = 1,
             alpha = 0.1) +
  geom_violin(aes(color = imagery),
              fill = 'gray60',
              linewidth = 0.75,
              alpha = 0.4,
              draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_text(data = rts_status_pvalues,
            aes(x = x_pos, y = star_y_pos, label = star_label),
            inherit.aes = FALSE) +
  # geom_text(data = rts_status_pvalues,
  #           aes(x = x_pos, y = label_y_pos, label = p_label),
  #           inherit.aes = FALSE) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels,
                     guide = 'none') +
  facet_wrap(~ imagery, 
             strip.position = 'bottom', 
             scales = 'free_x',
             labeller = labeller(imagery = imagery_labeller)) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank(),
        panel.spacing = unit(0, "lines"), 
        strip.background = element_blank(),
        strip.placement = "outside")
```

## Drivers of Unexpected RTS Prediction Performance

### Classify Features Using Confidence Interval Approach

This approach first uses the 95% CI of the model parameters to determine whether RTS features were predicted better or worse than expected based on the model. Next, the threshold at which RTS size doesn't impact IoU is determined from where the slope of the model approaches 0 (currently using slope < 1e-06) for each imagery type. RTS features smaller than this threshold that were predicted better than expected are analyzed later to determine why some small RTS can be identified from the imagery.


```{r, include = FALSE}
# take the derivative of the non-linear function to find where the slope approaches 0
# get parameters from `summary({model})$parameters`
maxar_d1 <- D(expression(y = 0.8066169 * x / (3110.6944035 + x)), name = 'x')
planet_d1 <- D(expression(y = 0.7629412 * x / (3980.4699512 + x)), name = 'x')
sentinel_d1 <- D(expression(y = 0.6648809 * x / (3775.0197095 + x)), name = 'x')

# estimate where the derivative crosses 1e-05
estimate_grid <- tibble(rts_area = seq(10000, 70000, by = 0.1))

maxar_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(maxar_d1, rts_area))
planet_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(planet_d1, rts_area))
sentinel_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(sentinel_d1, rts_area))

maxar_cross <- maxar_est %>%
  slice(which.min(abs(1e-05-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-05
planet_cross <- planet_est %>%
  slice(which.min(abs(1e-05-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-05
sentinel_cross <- sentinel_est %>%
  slice(which.min(abs(1e-05-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-05

size_thresholds <- tibble(imagery = c('Maxar', 'Planet', 'Sentinel-2'),
                          rts_threshold = c(maxar_cross, 
                                            planet_cross, 
                                            sentinel_cross))
rm(maxar_d1, planet_d1, sentinel_d1,
   maxar_est, planet_est, sentinel_est,
   maxar_cross, planet_cross, sentinel_cross,
   estimate_grid)
```

```{r}
rts_iou_thresholds <- polys %>%
  as_tibble() %>%
  group_by(imagery) %>%
  summarise(rts_iou_mean = mean(rts_iou),
            rts_sd = sd(rts_iou)) %>%
  mutate(rts_iou_threshold = rts_iou_mean)

polys <- polys %>%
  mutate(
    size_threshold = case_when(
      imagery == 'Maxar' ~ 
        filter(size_thresholds, imagery == 'Maxar')$rts_threshold,
      imagery == 'Planet' ~ 
        filter(size_thresholds, imagery == 'Planet')$rts_threshold,
      imagery == 'Sentinel-2' ~ 
        filter(size_thresholds, imagery == 'Sentinel-2')$rts_threshold
    ),
    iou_threshold = case_when(
      imagery == 'Maxar' ~ 
        filter(rts_iou_thresholds, imagery == 'Maxar')$rts_iou_threshold,
      imagery == 'Planet' ~ 
        filter(rts_iou_thresholds, imagery == 'Planet')$rts_iou_threshold,
      imagery == 'Sentinel-2' ~ 
        filter(rts_iou_thresholds, imagery == 'Sentinel-2')$rts_iou_threshold
    ),
    pq_ci = factor(
      case_when(
        rts_iou > iou_pred_upr & rts_iou > iou_threshold ~ 'High',
        rts_iou < iou_pred_lwr ~ 'Low',
        TRUE ~ 'Expected'
      ),
      levels = c('High', 'Expected', 'Low')),
    pq_ci_size = factor(
      case_when(
        rts_iou > iou_pred_upr & rts_iou > iou_threshold & 
          rts_area <= size_threshold ~ 'High',
        rts_iou < iou_pred_lwr & rts_area > size_threshold ~ 'Low',
        TRUE ~ 'Expected'
      ),
      levels = c('High', 'Expected', 'Low'))
  )
```

Size at which predicted RTS IoU is higher than the median RTS IoU

```{r}
min_rts_area <- iou_ci %>%
  left_join(polys %>%
              as_tibble() %>%
              summarise(rts_iou_median = median(rts_iou), 
                        .by = c('imagery')) %>%
              select(imagery, rts_iou_median),
            by = 'imagery') %>%
  filter(abs(prediction - rts_iou_median) == min(abs(prediction - rts_iou_median)),
         .by = 'imagery') %>%
  left_join(size_single_thresholds %>%
              mutate(rts_threshold = ceiling(rts_threshold/100)*100),
            by = 'imagery') %>%
  mutate(rts_iou_median = round(rts_iou_median, 2),
         rts_area = ceiling(rts_area/100)*100) %>%
  select(`Imagery` = imagery, 
         `Median RTS IoU` = rts_iou_median,
         `RTS Area to Exceed Median RTS IoU` = rts_area,
         `RTS Area Threshold Where Slope <1e-05` = rts_threshold)

write.csv(min_rts_area,
          './tables/rts_area_thresholds.csv')

knitr::kable(min_rts_area)
```

```{r, fig.width = 12}
ggplot(polys, 
       aes(x = rts_area, 
           y = rts_iou)) +
  geom_point(aes(color = pq_ci, shape = yg), size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, ymin = lwr, ymax = upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  # coord_cartesian(ylim = c(0, 1)) +
  facet_grid(. ~ imagery) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

# ggsave('./figures/area_iou.pdf',
#        height = 4.5,
#        width = 6.5)
# ggsave('./figures/area_iou.jpg',
#        height = 4.5,
#        width = 6.5)
```

```{r, fig.width = 12}
ggplot(polys, 
       aes(x = rts_area, 
           y = rts_iou)) +
  geom_point(aes(color = pq_ci_size, shape = yg), size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, 
                  ymin = lwr, 
                  ymax = upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci,
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  geom_vline(data = size_thresholds,
             aes(xintercept = rts_threshold, color = imagery),
            linetype = 'dashed') +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  # coord_cartesian(ylim = c(0, 1)) +
  facet_grid(. ~ imagery)
```
```{r, fig.width = 12}
ggplot(single_rts, 
       aes(x = rts_area, 
           y = rts_iou)) +
  geom_point(data = polys %>%
               filter(st_geometry_type(val_geometry) == 'MULTIPOLYGON'),
             aes(x = rts_area, 
                 y = rts_iou,
             color = 'Multiple RTS Features\n(not included)'),
             size = 1,
             shape = 16,
             inherit.aes = FALSE) +
  scale_color_manual(name = '', values = 'gray') +
  new_scale('color') +
  geom_point(aes(color = pq_ci, shape = yg)) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = single_rts_iou_ci,
              aes(x = rts_area, ymin = lwr, ymax = upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = single_rts_iou_ci, 
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  # geom_vline(data = size_single_thresholds,
  #            aes(xintercept = rts_threshold, color = imagery),
  #           linetype = 'dashed') +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU',
                     limits = c(0, 1.02)) +
  scale_shape_manual(name = 'Region',
                     values = c(16, 1)) +
  facet_grid(. ~ imagery) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

# ggsave('./figures/area_iou.pdf',
#        height = 4.5,
#        width = 6.5)
# ggsave('./figures/area_iou.jpg',
#        height = 4.5,
#        width = 6.5)
```

```{r}
knitr::kable(size_thresholds)
knitr::kable(polys %>%
               as_tibble() %>%
               count(imagery, pq_ci) %>%
               pivot_wider(names_from = pq_ci, values_from = n))
```

Is performance class the same across imagery sources for most RTS features?

```{r}
polys <- polys %>%
  mutate(
    pq_ci_offset = case_when(
      imagery == 'Maxar' ~ as.numeric(pq_ci) - 0.2,
      imagery == 'Planet' ~ as.numeric(pq_ci),
      imagery == 'Sentinel-2' ~ as.numeric(pq_ci) + 0.2
      )
    )

rts_pq <- polys %>%
  as_tibble() %>%
  select(id, imagery, rts_area, name_long, pq_ci) %>%
  mutate(
    pq_ci_high = case_when(pq_ci == 'High' ~ 1,
                                TRUE ~ 0),
    pq_ci_expected = case_when(pq_ci == 'Expected' ~ 1,
                                    TRUE ~ 0),
    pq_ci_low = case_when(pq_ci == 'Low' ~ 1,
                               TRUE ~ 0)
  ) %>%
  group_by(id) %>%
  summarise(High = sum(pq_ci_high),
            Expected = sum(pq_ci_expected),
            Low = sum(pq_ci_low)) %>%
  pivot_longer(High:Low, 
               names_to = 'pq_ci', 
               values_to = 'n') %>%
  group_by(id) %>%
  mutate(
    pq_ci = factor(pq_ci,
                        levels = c('High', 'Expected', 'Low')),
    group_max = max(n),
    group_pq_max = pq_ci[which(n == max(n))]
  ) %>%
  ungroup() %>%
  mutate(
    group_pq_2nd = case_when(
      n == 1 ~ pq_ci,
      TRUE ~ NA
      ),
    plotting_order = case_when(
      group_max == 2 & group_pq_max == 'High' & group_pq_2nd == 'Low' ~ 1,
      group_max == 3 & group_pq_max == 'High' ~ 2,
      group_max == 2 & group_pq_max == 'High' & group_pq_2nd == 'Expected' ~ 3,
      group_max == 2 & group_pq_max == 'Expected' & group_pq_2nd == 'High' ~ 4,
      group_max == 3 & group_pq_max == 'Expected' ~ 5,
      group_max == 2 & group_pq_max == 'Expected' & group_pq_2nd == 'Low' ~ 6,
      group_max == 2 & group_pq_max == 'Low' & group_pq_2nd == 'Expected' ~ 7,
      group_max == 3 & group_pq_max == 'Low' ~ 8
    )
  ) %>%
  arrange(plotting_order, id) %>%
  mutate(id = factor(id,
                     levels = c(unique(.$id))))

polys <- polys %>%
  mutate(id = factor(id,
                     levels = c(unique(rts_pq$id))))
```

```{r}
ggplot(polys, 
       aes(x = id, y = pq_ci_offset, color = imagery)) +
  geom_point() +
  scale_y_reverse(name = 'Prediction Quality',
                     breaks = c(1, 2, 3),
                     labels = pq_labels) +
  scale_x_discrete(name = 'RTS Features') +
  scale_color_manual(values = imagery_colors) +
  # facet_grid(name_long ~ ., scales = 'free_y') +
  theme(axis.text.x = element_blank(),
        legend.title = element_blank(),
        panel.grid.minor = element_blank()) +
  coord_fixed(ratio = 10)

# ggsave('./figures/prediction_quality_by_imagery.pdf',
#        height = 2.5,
#        width = 6.5)
# ggsave('./figures/prediction_quality_by_imagery.jpg',
#        height = 2.5,
#        width = 6.5)
```

### Zonal Statistics

```{r}
input_data <- input_data %>%
  left_join(polys %>%
              as_tibble() %>%
              select(id, imagery, yg, rts_area, rts_shape, rts_iou, mean_iou, 
                     mean_iou_v2, pq_ci, pq_ci_size),
            by = c('imagery', 'id')) %>%
  left_join(masks_df, by = c('imagery', 'id', 'x', 'y'))
```

```{r}
zonal_stats <- input_data %>%
  filter(mask == 1) %>%
  group_by(imagery, id, yg, rts_class, rts_area, rts_shape, rts_iou, mean_iou, 
           mean_iou_v2, pq_ci, pq_ci_size) %>%
  summarise(across(c(prediction, r:sr), mean, .names = "{.col}_mean"),
            across(r:sr, sd, .names = "{.col}_sd")) %>%
  pivot_wider(names_from = 'rts_class', 
              values_from = c(prediction_mean:sr_sd)) %>%
  mutate(r_mean_delta = (r_mean_rts - r_mean_bg),
         b_mean_delta = (b_mean_rts - b_mean_bg),
         g_mean_delta = (g_mean_rts - g_mean_bg),
         lum_mean_delta = (lum_mean_rts - lum_mean_bg),
         nir_mean_delta = (nir_mean_rts - nir_mean_bg),
         ndvi_mean_delta = (ndvi_mean_rts - ndvi_mean_bg),
         ndwi_mean_delta = (ndwi_mean_rts - ndwi_mean_bg),
         elev_mean_delta = (elev_mean_rts - elev_mean_bg),
         sr_mean_delta = (sr_mean_rts - sr_mean_bg),
         r_sd_delta = (r_sd_rts - r_sd_bg),
         b_sd_delta = (b_sd_rts - b_sd_bg),
         g_sd_delta = (g_sd_rts - g_sd_bg),
         lum_sd_delta = (lum_sd_rts - lum_sd_bg),
         nir_sd_delta = (nir_sd_rts - nir_sd_bg),
         ndvi_sd_delta = (ndvi_sd_rts - ndvi_sd_bg),
         ndwi_sd_delta = (ndwi_sd_rts - ndwi_sd_bg),
         elev_sd_delta = (elev_sd_rts - elev_sd_bg),
         sr_sd_delta = (sr_sd_rts - sr_sd_bg)) %>%
  pivot_longer(r_mean_rts:sr_sd_delta, 
               names_to = 'variable', 
               values_to = 'value') %>%
  separate(variable, 
           into = c('variable', 'metric', 'rts_class'), 
           sep = '_') %>%
  mutate(rts_class = factor(case_when(rts_class == 'rts' ~ 'RTS',
                                      rts_class == 'bg' ~ 'Background',
                                      rts_class == 'delta' ~ 'Delta'),
                            levels = c('RTS', 'Delta', 'Background'))) %>%
  pivot_wider(names_from = c('variable', 'metric'),
              values_from = 'value')
```

```{r}
lm_output <- zonal_stats %>%
  select(imagery:sr_sd, pq_ci, pq_ci_size) %>%
  pivot_longer(r_mean:sr_sd, names_to = 'variable', values_to = 'value') %>%
  group_by(rts_class, imagery, variable) %>%
  nest() %>% 
  mutate(models_pq = map(data, 
                         possibly(lm_pq, otherwise = NA)),
         summary_pq = map(models_pq, 
                          possibly(lm_summary, otherwise = NA)),
         contrasts_pq = map(models_pq, 
                            possibly(lm_contrasts_pq, 
                                     otherwise = NA)))
```

```{r}
zonal_stats_contrasts <- lm_output %>%
  select(imagery, rts_class, variable, contrasts_pq) %>%
  unnest(cols = c(contrasts_pq)) %>%
  filter(p_value <= 0.1) %>%
  separate_wider_delim(contrast, 
                       delim = ' - ', 
                       names = c('x_min', 'x_max'), 
                       cols_remove = FALSE) %>%
  mutate(x_min = as.numeric(factor(x_min,
                                   levels = pq_labels)) + 0.05,
         x_max = as.numeric(factor(x_max,
                                   levels = pq_labels)) - 0.05)
```

```{r}
# calculate figure y-limits by hand
# (1.5*IQR is the upper and lower whisker limit; 1.05 is the default axis expansion by ggplot)
zonal_stats_limits <- zonal_stats %>%
  select(imagery:sr_sd, pq_ci) %>%
  pivot_longer(r_mean:sr_sd,  names_to = 'variable', values_to = 'value') %>%
group_by(imagery, pq_ci, rts_class, variable) %>%
  summarise(
    # lwr = min(trim_outliers(value), na.rm = TRUE), # use this if removing outliers from plots
    # upr = max(trim_outliers(value), na.rm = TRUE),
    lwr = min(value, na.rm = TRUE),
    upr = max(value, na.rm = TRUE)
    ) %>%
  mutate(lim_lwr = upr - (upr - lwr)*1.05,
         lim_upr = lwr + (upr - lwr)*1.05) %>%
  group_by(variable, rts_class) %>%
  summarise(lwr = min(lim_lwr),
            upr = max(lim_upr))
```

```{r}
zonal_stats_contrasts <- zonal_stats_contrasts %>%
  left_join(zonal_stats_limits, by = c('variable', 'rts_class')) %>%
  group_by(imagery, rts_class, variable) %>%
  mutate(n = n(),
         y = case_when(n >= 2 & contrast == 'High - Low' ~ lwr + (upr - lwr)*1.2,
                       TRUE ~ lwr + (upr - lwr)*1.05),
         upr = case_when(n >= 2 & contrast == 'High - Low' ~ lwr + (upr - lwr)*1.3,
                         TRUE ~ lwr + (upr - lwr)*1.15))

# add new upr limits back to limits tibble
zonal_stats_limits <- zonal_stats_limits %>%
  left_join(zonal_stats_contrasts %>%
              select(imagery, rts_class, variable, upr) %>%
              group_by(rts_class, variable) %>%
              summarise(new_upr = max(upr)),
            by = c('rts_class', 'variable')) %>%
  mutate(upr = case_when(!is.na(new_upr) ~ new_upr,
                         TRUE ~ upr)) %>%
  select(-new_upr)

```


These plots summarize the input data values (mean or standard deviation) in RTS cells, background cells, and the normalized difference between the two (`Delta = RTS - Background`). Most of the input layer names should be self explanatory, but for the others:

lum = [luminance](https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color) = `0.299*r + 0.587*g + 0.114*b` 

sr = shaded relief

```{r, include = FALSE}
variables <- colnames(zonal_stats %>%
                        ungroup() %>%
                        select(r_mean:sr_sd))
zonal_stats_figs <- map(
  variables,
  ~ plot_zonal_stats(
    x_var = 'pq_ci',
    y_var = .x, 
    contrasts = zonal_stats_contrasts,
    limits = zonal_stats_limits)
)
names(zonal_stats_figs) <- variables
```

A few takeaway points:

- Brighter RTS against a darker background are predicted better. Doesn't seem to be related to seasonality.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['r_mean']]
zonal_stats_figs[['g_mean']]
zonal_stats_figs[['b_mean']]
zonal_stats_figs[['lum_mean']]
```

-   Well predicted RTS tend to have more consistent NDWI relative to the surrounding landscape, while poorly predicted RTS tend to have less difference in the variability of NDWI between RTS and background pixels.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['ndwi_sd']]
```

- RTS are predicted better where the background has variable plant growth and the RTS feature has spatially consistent plant growth (Planet and Sentinel-2 models).

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['ndvi_sd']]
```

-   The standard deviation of elevation (surface roughness) figure indicates that the Maxar model struggles to identify RTS where RTS (and, perhaps, the landscape) has high surface roughness. There is also a slight trend that where there is higher variability in elevation within RTS relative to the background cells, RTS features are identified more easily in the Planet and Sentinel models. I.e. smooth landscape with uneven RTS is easy for the model to find.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['elev_sd']]
```

I didn't find much interesting about the rest of these figures, but they are included  here for completeness:

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['nir_mean']]
zonal_stats_figs[['ndvi_mean']]
zonal_stats_figs[['ndwi_mean']]
zonal_stats_figs[['elev_mean']]
zonal_stats_figs[['sr_mean']]
zonal_stats_figs[['r_sd']]
zonal_stats_figs[['g_sd']]
zonal_stats_figs[['b_sd']]
zonal_stats_figs[['lum_sd']]
zonal_stats_figs[['nir_sd']]
zonal_stats_figs[['sr_sd']]
```

### Prediction Probability

```{r}
rts_labeller <- as_labeller(c(Maxar = 'Maxar', Planet = 'Planet', `Sentinel-2` = '`Sentinel-2`',
                              rts = 'RTS', bg = 'Background'),
                            default = label_parsed)

```

NIR/NDVI

```{r}
ggplot(input_data, aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data, aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  # geom_bin_2d(data = input_data %>%
  #               filter(rts_class == 'rts'),
  #             aes(x = ndvi, y = prediction),
  #             inherit.aes = FALSE) +
  # scale_fill_gradient(name = 'Density (RTS)',
  #                     low = '#CCFF99',
  #                     high = '#003300',
  #                     trans = "log10",
  #                     limits = c(1, 1000000),
  #                     guide = guide_legend(order = 1)) +
  # new_scale('fill') +
  # geom_bin_2d(data = input_data %>%
  #               filter(rts_class == 'bg'),
  #             aes(x = ndvi, y = prediction),
  #             inherit.aes = FALSE) +
  # scale_fill_gradient(name = 'Density (Background)',
  #                     low = '#CCCCCC',
  #                     high = '#000000',
  #                     trans = "log10",
  #                     limits = c(1, 1000000),
  #                     guide = guide_legend(order = 2)) +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

```{r}
ggplot(input_data %>%
         filter(imagery == 'Maxar'), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Maxar')

ggplot(input_data %>%
         filter(imagery == 'Planet'), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Planet')

ggplot(input_data %>%
         filter(imagery == 'Sentinel-2'), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Sentinel-2')

ggplot(input_data %>%
         filter(imagery == 'Maxar'), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Maxar')

ggplot(input_data %>%
         filter(imagery == 'Planet'), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Planet')

ggplot(input_data %>%
         filter(imagery == 'Sentinel-2'), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Sentinel-2')
```

NDWI

```{r}
ggplot(input_data, aes(x = ndwi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDWI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

Elevation

```{r}
ggplot(input_data, aes(x = elev, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Relative Elevation') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

Others

```{r}
ggplot(input_data, aes(x = r, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Red') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data, aes(x = g, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Green') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data, aes(x = b, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Blue') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data, aes(x = sr, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Shaded Relief') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

### PCA Analysis

```{r}
zonal_stats_class <- zonal_stats %>%
  filter(rts_class %in% c('RTS', 'Background')) %>%
  mutate(rts_class = factor(rts_class,
                            levels = c('RTS', 'Background')))

zonal_stats_pca <- prcomp(zonal_stats_class %>%
                            ungroup() %>%
                            select(r_mean:b_mean, nir_mean:sr_mean,
                                   r_sd:b_sd, nir_sd:sr_sd),
                          center = TRUE,
                          scale = TRUE)

zonal_stats_class <- zonal_stats_class %>%
  cbind(zonal_stats_pca[['x']])
```

PCA - Imagery color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~imagery,
        colors = imagery_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

PCA - Prediction quality color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Maxar

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Maxar'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Planet

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Planet'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Sentinel-2

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Sentinel-2'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'pq_ci',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_manual(name = 'Prediction Quality', 
                     labels = pq_labels,
                     values = pq_colors) +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'pq_ci',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_manual(name = 'Prediction Quality', 
                     labels = pq_labels,
                     values = pq_colors) +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'pq_ci',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_manual(name = 'Prediction Quality', 
                     labels = pq_labels,
                     values = pq_colors) +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

PCA - RTS probability color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Maxar

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Maxar'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Planet

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Planet'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Sentinel-2

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Sentinel-2'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'prediction_mean_rts',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'Mean RTS Probability') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'prediction_mean_rts',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'Mean RTS Probability') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'prediction_mean_rts',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'Mean RTS Probability') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

PCA - IoU color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~rts_iou,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'rts_iou',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'IoU') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'rts_iou',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'IoU') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'rts_iou',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'IoU') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

PCA - RTS area color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~log10(rts_area),
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'rts_area',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS Area') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'rts_area',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS Area') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'rts_area',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS Area') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

### Prediction Quality Random Forest

```{r}
pq_rf <- randomForest::randomForest(pq_ci ~ .,
                      data = zonal_stats %>%
                        as_tibble() %>%
                        select(-c(id, rts_iou, mean_iou, mean_iou_v2, 
                                  pq_ci_size, pq_ci_offset, prediction_mean_rts,
                                  prediction_mean_bg)) %>%
                        mutate(rts_class = case_when(
                          rts_class == 'RTS' ~ 'rts',
                          rts_class == 'Delta' ~ 'delta',
                          rts_class == 'Background' ~ 'bg')
                        ) %>%
                        pivot_wider(names_from = rts_class,
                                    values_from = r_mean:sr_sd))
```

```{r}
print(pq_rf)
```

No, we can't predict the prediction quality very well based on the input data, feature size, shape, region, etc.

```{r, fig.width = 7, fig.height = 7}
randomForest::varImpPlot(pq_rf)
```


## RTS Morphology

```{r}
ggplot(polys, 
       aes(x = rts_shape, y = rts_area, color = pq_ci, shape = yg)) +
  geom_point() +
  scale_x_continuous(name = 'RTS Shape (Polsby-Popper)') +
  scale_y_log10(name = expression('RTS Area (m'^2 * ')')) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  facet_grid(. ~ imagery)
```

```{r}
rts_shape_area_iou <- ggplot(polys, 
       aes(x = rts_shape, y = rts_area, color = rts_iou, shape = yg)) +
  geom_point() +
  scale_x_continuous(name = 'RTS Shape (Polsby-Popper)') +
  scale_y_log10(name = expression('RTS Area (m'^2 * ')'),
                labels = scales::label_number(big.mark = '')) +
  scale_color_viridis(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  facet_grid(. ~ imagery)
rts_shape_area_iou

# ggsave('./figures/rts_shape_area.pdf',
#        shape_area_iou,
#        height = 4,
#        width = 6.5)
# ggsave('./figures/rts_shape_area.jpg',
#        shape_area_iou,
#        height = 4,
#        width = 6.5)

ggplot(polys %>%
         filter(st_geometry_type(val_geometry) == 'POLYGON'), 
       aes(x = rts_shape, y = rts_area, color = rts_iou, shape = yg)) +
  geom_point() +
  scale_x_continuous(name = 'RTS Shape (Polsby-Popper)') +
  scale_y_log10(name = expression('RTS Area (m'^2 * ')'),
                labels = scales::label_number(big.mark = '')) +
  scale_color_viridis(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  facet_grid(. ~ imagery)
```

```{r}
polys <- polys %>%
  mutate(rts_area_log10 = log10(rts_area))

smallest <- rts_iou ~ 1
biggest <- rts_iou ~ rts_area_log10 * rts_shape
m <- lm(rts_iou ~ rts_area_log10 * rts_shape, 
        data = polys %>%
          filter(imagery == 'Maxar' & st_geometry_type(val_geometry) == 'POLYGON'))
maxar_iou_lm <- stats::step(m, scope = list(lower = smallest, upper = biggest))

m <- lm(rts_iou ~ rts_area_log10 * rts_shape, 
        data = polys %>%
          filter(imagery == 'Planet' & st_geometry_type(val_geometry) == 'POLYGON'))
planet_iou_lm <- stats::step(m, scope = list(lower = smallest, upper = biggest))
summary(planet_iou_lm)
# the r2 and AIC are about the same for Planet with rts_iou ~ rts_area_log10
# or rts_iou ~ rts_area_log10 * rts_shape
# to allow comparison of the imagery types, I will stick with the more complex
# model that was chosen as the best for Maxar
planet_iou_lm <- lm(rts_iou ~ rts_area_log10 * rts_shape,
                    data = polys %>%
          filter(imagery == 'Planet' & st_geometry_type(val_geometry) == 'POLYGON'))

m <- lm(rts_iou ~ rts_area_log10 * rts_shape, 
        data = polys %>%
          filter(imagery == 'Sentinel-2' & st_geometry_type(val_geometry) == 'POLYGON'))
sentinel_iou_lm <- stats::step(m, scope = list(lower = smallest, upper = biggest))
summary(sentinel_iou_lm)
# the r2 and AIC are about the same for Planet with rts_iou ~ rts_area_log10
# or rts_iou ~ rts_area_log10 * rts_shape
# to allow comparison of the imagery types, I will stick with the more complex
# model that was chosen as the best for Maxar
sentinel_iou_lm <- lm(rts_iou ~ rts_area_log10 * rts_shape, 
        data = polys %>%
          filter(imagery == 'Sentinel-2' & st_geometry_type(val_geometry) == 'POLYGON'))

iou_lm_output <- tidy(maxar_iou_lm) %>%
  mutate(Imagery = 'Maxar',
         r2 = summary(maxar_iou_lm)$r.squared) %>%
  rbind(tidy(planet_iou_lm) %>%
          mutate(Imagery = 'Planet',
                 r2 = summary(planet_iou_lm)$r.squared)) %>%
  rbind(tidy(sentinel_iou_lm) %>%
          mutate(Imagery = 'Sentinel-2',
                 r2 = summary(sentinel_iou_lm)$r.squared)) %>%
  mutate(across(c(r2, estimate:p.value), ~ round(., digits = 3))) %>%
  select(Imagery, r2, Term = term, Estimate = estimate, `SE` = std.error, `p-value` = p.value)

knitr::kable(iou_lm_output)

# write.csv(iou_lm_output,
#           './tables/iou_lm_summary.csv',
#           row.names = FALSE)
```


## YG Region

The YG Region has smaller RTS features that tend to be more elongated, making them thin and hard to detect across all three imagery types. These factors combined are probably responsible for the poorer IoU scores in the region. The highest RTS IoUs seen in the Maxar and Planet models were just above 0.6, while in the Sentinel-2 model, they were around 0.5.

```{r}
ggplot(polys,
       aes(x = rts_area, y = rts_iou, color = rts_shape, shape = yg)) +
  geom_point() +
  scale_x_continuous(name = expression('RTS Area (m'^2 * ')')) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_color_viridis(name = 'RTS Shape\n(Polsby-Popper)') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  facet_grid(imagery ~ .)
```

The Yamal-Gydan Peninsula appears to be both drier and have smaller RTS features, so these two variables are hard to disentangle.

```{r}
zonal_stats_class %>%
  group_by(imagery, id, yg) %>%
  summarise(ndwi_mean = mean(ndwi_mean),
            rts_area = first(rts_area),
            region = first(yg)) %>%
ggplot(aes(x = ndwi_mean, y = rts_area, color = yg)) +
  geom_point()
```

All models are tripped up by the Yamal/Gydan Region.

```{r}
rts_pq_hist <- ggplot(polys,
       aes(x = yg, fill = pq_ci)) +
  geom_bar(position = 'fill') +
  scale_x_discrete(name = 'Region') +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(name = 'Prediction Quality',
                    values = pq_colors) +
  facet_grid(. ~ imagery) +
  theme(axis.title.y = element_blank())
rts_pq_hist

# ggsave('./figures/rts_pq_hist.pdf',
#        rts_pq_hist,
#        height = 4,
#        width = 6.5)
# ggsave('./figures/rts_pq_hist.jpg',
#        rts_pq_hist,
#        height = 4,
#        width = 6.5)
```

```{r, fig.height = 5, fig.width = 7}
ggplot(polys,
       aes(x = rts_area, y = rts_iou, shape = yg, color = rts_shape)) +
  geom_point() +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  scale_color_viridis(name = 'RTS Shape') +
  facet_grid(pq_ci ~ imagery)
```

```{r, fig.height = 5, fig.width = 7}
ggplot(polys,
       aes(x = rts_area, y = rts_iou, shape = yg, color = rts_shape)) +
  geom_point() +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  scale_color_viridis(name = 'RTS Shape') +
  facet_grid(. ~ imagery)
```

```{r, fig.height = 5, fig.width = 7}
ggplot(polys,
       aes(x = rts_area, y = rts_shape, shape = yg, color = rts_iou)) +
  geom_point() +
  scale_x_log10(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS Shape') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  scale_color_viridis(name = 'RTS IoU') +
  facet_grid(pq_ci ~ imagery)
```


## Case Studies

The one really large RTS that was poorly predicted in Planet and Sentinel models:

-   May be that the RTS being so big is causing issues with the model (missing edges in the imagery)
-   I'm not sure if this is impacting the prediction, but the tile for Sentinel is pretty different and includes a bunch of open water that's not in either of the other images.
-   The RTS features seem to be brighter relative to the background in the poorly predicted ones, which is backwards from the conclusions of the zonal stats analysis.

```{r}
rts_id <- polys %>%
  as_tibble() %>%
  filter(rts_area > size_threshold & pq_ci == 'Low') %>%
  select(id) %>%
  mutate(id = as.character(id)) %>%
  pull(id) %>%
  unique()

ggplot(data = polys %>%
         filter(id == rts_id)) +
  geom_raster(data = input_data %>%
                filter(id == rts_id),
              aes(x = x, y = y, fill = color_hex),
              inherit.aes = FALSE) +
  scale_fill_manual(breaks = levels(input_data$color_hex),
                    values = levels(input_data$color_hex),
                    guide = 'none') +
  geom_sf(aes(geometry = val_geometry,
              color = 'Validation'),
          fill = 'transparent',
          linewidth = 0.5) +
  scale_color_manual(values = c('gray90')) +
new_scale('color') +
  geom_sf(aes(geometry = pred_geometry,
              color = pq_ci),
          fill = 'transparent',
          linewidth = 0.5) +
  scale_color_manual(name = '',
                     values = pq_colors[2:3]) +
  facet_grid(imagery ~ .) +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggplot(zonal_stats %>%
         filter(rts_area > 35000),
       aes(x = imagery, y = lum_mean, color = pq_ci)) +
  geom_point() +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  # scale_shape_manual(values = c(16, 2, 1)) +
  facet_grid(rts_class ~ .)
```

The RTS features which had different prediction qualities across all three models:

```{r}
polys <- polys %>%
  as_tibble() %>%
  group_by(id) %>%
  mutate(pq_n_unique = length(unique(pq_ci)))

rts_ids <- polys %>%
  filter(pq_n_unique == 3) %>%
  mutate(id = as.character(id)) %>%
  pull(id) %>%
  unique()
```

```{r}
for (rts_id in rts_ids) {
  print(
    ggplot(data = polys %>%
             filter(id == rts_id)) +
      geom_raster(data = input_data %>%
                    filter(id == rts_id),
                  aes(x = x, y = y, fill = color_hex),
                  inherit.aes = FALSE) +
      scale_fill_manual(breaks = levels(input_data$color_hex),
                        values = levels(input_data$color_hex),
                        guide = 'none') +
      geom_sf(aes(geometry = val_geometry,
                  color = 'Validation'),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(values = c('gray90')) +
      new_scale('color') +
      geom_sf(aes(geometry = pred_geometry,
                  color = pq_ci),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(name = '',
                         values = pq_colors) +
      facet_grid(imagery ~ .) +
      theme(axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank())
  )
  
}
```

```{r}
ggplot(polys,
       aes(x = rts_area, y = rts_shape, color = factor(pq_n_unique))) +
  geom_point() +
  scale_x_log10(name = expression('RTS Area (m'^2 * ')')) +
  scale_y_continuous(name = 'RTS Shape') +
  scale_color_viridis(name = 'Number of Unique\nPrediction Quality\nDesignations Across\nImagery Types',
                      discrete = TRUE)
```

```{r}
ggplot(polys, aes(x = rts_area, y = pq_n_unique)) +
  geom_point() +
  scale_x_log10()

ggplot(polys, aes(x = rts_shape, y = pq_n_unique)) +
  geom_point()
```


## Plot Features

Visualize the RTS predictions

```{r fig.width = 12, fig.height = 4.8}
walk(pred_ids,
    ~ plot_prediction(.x))
```

Maxar High Quality Predictions

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'High' & imagery == 'Maxar') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'High' & imagery == 'Maxar') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[1], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Maxar Low Quality Predictions

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'Low' & imagery == 'Maxar') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'Low' & imagery == 'Maxar') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[3], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Planet High Quality Predictions

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'High' & imagery == 'Planet') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'High' & imagery == 'Planet') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[1], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Planet Low Quality Predictions

These images seem like they may be blurrier than the well predicted Planet RTS features.

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'Low' & imagery == 'Planet') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'Low' & imagery == 'Planet') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[3], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Sentinel High Quality Predictions

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'High' & imagery == 'Sentinel-2') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'High' & imagery == 'Sentinel-2') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[1], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Sentinel Low Quality Predictions

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'Low' & imagery == 'Sentinel-2') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'Low' & imagery == 'Sentinel-2') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[3], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

