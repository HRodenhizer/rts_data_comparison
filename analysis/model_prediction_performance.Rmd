---
output:
  html_document: default
  pdf_document: default
---

# RTS Model Imagery Performance Analysis

## TODO:

- try making crop polygon over north pole by buffering a point and using `st_wrap_dateline()` to get rid of extra lines introduced into country outlines
-   Finalize RTS sample figure. Show outlines of predictions for all features within one tile? Fix RTS label justification when ggplot2 is next updated. Make the figure narrower? Add labels for region?

## Set-Up
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

## Load Libraries

```{r, include = FALSE}
library(terra)
library(sf)
library(lwgeom)
library(spData)
library(leaflet)
library(viridis)
library(googledrive)
library(jsonlite)
library(smoothr)
library(tidymodels)
library(emmeans)
library(nlstools)
library(Ryacas)
library(ggnewscale)
library(patchwork)
library(ggsignif)
library(ggfortify)
library(plotly)
library(ggthemes)
library(tidyverse)
theme_set(theme_bw())
```

## Prep Google Drive Authentication

```{r, include = FALSE}
drive_auth(email = 'hrodenhizer@woodwellclimate.org')
```


## Define Functions

### assign_conf_stars

```{r, include = FALSE}
assign_conf_stars <- function(x) {
  case_when(x <= 0.0001 ~ '****',
            x <= 0.001 ~ '***',
            x <= 0.01 ~ '**',
            x <= 0.05 ~ '*',
            x <= 0.1 ~ '.',
            x > 0.1 ~ '')
}
  
```

### avg_precision

```{r, include = FALSE}
avg_precision <- function(recall, precision) {
  
  ap <- sum((recall[1:length(recall) - 1] - recall[2:length(recall)])*precision[1:length(precision) - 1], na.rm = TRUE)
  return(ap)
  
}
```

### bbox

```{r, include = FALSE}
bbox <- function(prediction) {
  bbox <- prediction[['prediction']] %>%
    ext() %>%
    st_bbox(crs = crs(prediction)) %>%
    st_as_sfc() %>%
    st_as_sf() %>%
    mutate(id = get_rast_id(prediction)) %>%
    rename(bbox_geometry = x)
  
  return(bbox)
  
}
```

### calc_rts_threshold

```{r}
calc_rts_threshold <- function(prediction, thresholds) {
  
  mean_iou <- c()
  
  for (threshold in thresholds) {
    
    # classify the prediction
    prediction[['pred_class']] <- classify(
      prediction[['prediction']],
      matrix(c(0, threshold, 0,
               threshold, 1, 1),
             byrow = TRUE,
             ncol = 3),
      right = FALSE
    )
    
    # calculate ground truth classes
    prediction[['zones']] <- prediction[['pred_class']] + prediction[['validation']]
    prediction[['area']] <- cellSize(prediction[['zones']])
    
    # calculate zonal stats
    areas <- zonal(prediction[['area']],
                   prediction[['zones']],
                   fun = 'sum')
    
    # calculate mean IoU
    rts_iou <- ifelse(is.na(areas$area[3]),
                      0,
                      areas$area[3]/(areas$area[3] + areas$area[2]))
    bg_iou <- areas$area[1]/(areas$area[1] + areas$area[2])
    mean_iou <- c(mean_iou, mean(c(rts_iou, bg_iou)))
    
    
  }
  
  output <- tibble(
    id = get_rast_id(prediction),
    threshold = thresholds,
    mean_iou = mean_iou
  )
  
  return(output)
  
}
```

### eval_expression

```{r, include = FALSE}
eval_expression <- function(expression, x) {
  return(eval(expression))
}
```

### feature_mask

```{r}
feature_mask <- function(validation, polys) {
  
  # get validation layer (all RTS features within the tile)
  val <- validation[['RTSlabel']]
  
  # get polygon ID associated with validation layer
  pid <- get_rast_id(val)
  
  # get the outline of the polygon of interest
  tgt <- polys %>%
    st_set_geometry('rts_geometry') %>%
    filter(id == pid) %>%
    rasterize(val, touches = TRUE)
  
  # calculate distance from validation polygons
  tgt_dist <- distance(tgt)
  val_dist <- distance(val)
  
  # in a few cases, the tgt_dist polygon might be slightly smaller than the val_dist raster. In this case, expand the tgt raster and re-calculate the distance
  tgt[is.na(tgt) & val == 1 & tgt_dist <= res(tgt_dist)[1]*2] <- 1
  tgt_dist <- distance(tgt)
  
  # create a mask that only keeps cells where the euclidean distance from the polygon of interest is smaller than the euclidean distance from all RTS features that occur within the tile
  mask <- tgt
  mask[tgt_dist <= val_dist] <- 1
  
  return(mask)
}
```

### filter_input_data

```{r}
filter_input_data <- function(input_list, ids) {
  input_filtered <- list()
  input_ids <- c()
  idx <- 0
  for (input in input_list) {
    input_id <- get_rast_id(input)
    if (input_id %in% ids) {
      idx <- idx + 1
      input_ids <- c(input_ids, input_id)
      input_filtered[[idx]] <- input
    }
    
  }
  
  input_ordered <- list()
  idx <- 0
  for (id in ids) {
    
    idx <- idx + 1
    input_ordered[[idx]] <- input_filtered[[which(input_ids == id)]]
  }
  
  return(input_ordered)
  
}
```

### get_rast_id

```{r, include = FALSE}
get_rast_id <- function(rast) {
  id <- first(str_split(last(str_split(sources(rast), 
                                       '/')[[1]]), 
                        '\\.')[[1]])
  return(id)
}
```

### googledrive_download

```{r, include = FALSE}
googledrive_download <- function(name, id, drive_resource, directory) {
  current <- as_dribble(id)
  make_my_dir(directory)
  filepath = paste0(directory, '/', name)
  
  if (!file.exists(filepath)) {
    print(filepath)
    dl <- drive_download(
      current,
      path = filepath)
  }

}
```

### input_as_df

```{r, include = FALSE}
input_as_df <- function(input, pred) {
  
  input[['prediction']] <- pred[['prediction']]
  
  # unify layer names
  names(input) <- c('r', 'g', 'b', 'ndvi', 'elev', 'sr', 'nir', 'ndwi', 'rts_class', 'prediction')
  
  # get polygon ID
  current_id <- get_rast_id(input)
  
  # add stretched rgb
  input_stretch <- stretch(subset(input, 1:3),
                          minv = 0,
                          maxv = 1,
                          minq = 0.01,
                          maxq = 1)
  names(input_stretch) <- c('r_stretch', 'g_stretch', 'b_stretch')
  
  input <- c(input, input_stretch)
  
  # convert to dataframe
  df <- input %>%
    as.data.frame(xy = TRUE) %>%
    mutate(id = current_id,
           rts_class = factor(
             case_when(is.na(rts_class) ~ 'bg',
                       rts_class == 1 ~ 'rts'),
             levels = c('rts', 'bg')
           ),
           r = r/max(r, na.rm = TRUE),
           g = g/max(g, na.rm = TRUE),
           b = b/max(b, na.rm = TRUE),
           lum = 0.299*r + 0.587*g + 0.114*b, # lum equation from: https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color
           nir = nir/max(nir, na.rm = TRUE)) %>%
    filter(!(is.na(r_stretch) | is.na(g_stretch) | is.na(b_stretch))) %>%
    mutate(
      color_hex = factor(rgb(r_stretch, g_stretch, b_stretch, maxColorValue = 1))
    )
  return(df)
  
}
```

### import_pred

```{r}
import_pred <- function(filepath) {
  raster <- rast(filepath)
  names(raster) <- c('prediction', 'validation')
  return(raster)
}
```

### lm_contrasts_pq

```{r}
lm_contrasts_pq <- function(model) {
  contrasts <- as_tibble(emmeans(model$fit,
                                 pairwise ~ pq_ci,
                                 adjust = 'dunnettx')$contrasts) %>%
    mutate(star_label = assign_conf_stars(p.value)) %>%
    select(contrast, estimate, se = SE, p_value = p.value, star_label)
}
```

### lm_pq

```{r}
lm_pq <- function(df) {
  model <- linear_reg() %>%
    fit(value ~ pq_ci, 
        data = df)
  return(model)
}
```

### lm_summary

```{r}
lm_summary <- function(model) {
  lm_output <- tidy(model) %>%
    rename_with(~ str_replace_all(., '\\.', '_'))
  return(lm_output)
}
```

### make_my_dir

```{r, include = FALSE}
make_my_dir <- function(output_dir) {

  if (!dir.exists(output_dir)){
    dir.create(output_dir, recursive = TRUE)
  }
  
}
```

### mask_as_df

```{r}
mask_as_df <- function(mask, pid) {
  st_as_sf(as.polygons(mask, values = FALSE)) %>%
           mutate(id = pid)
}
```

### my_nlsBootPredict

```{r}
my_nlsBootPredict <- function (nlsBoot, newdata, 
                               interval = c("confidence", "prediction")) 
{
  if (!inherits(nlsBoot, "nlsBoot"))
    stop("Use only with 'nlsBoot' objects")
  if (missing(newdata))
  {
    newdata <- get(as.character(nlsBoot$nls$data))
  }
  nlsformula <- formula(nlsBoot$nls)
  nlsresid <- resid(nlsBoot$nls)
  param <- nlsBoot$coefboot
  bootparam <- nlsBoot$coefboot
  niter <- length(nlsBoot$rse)
  
  "formula2function"<-function(formu){
    arg1		<- all.vars(formu)
    arg2		<- vector("list",length(arg1))
    names(arg2)	<- arg1
    Args		<- do.call("alist",arg2)
    fmodele		<- as.function(c(Args,formu))
    return(fmodele)
  }
  f1 <- formula2function(formula(nlsformula)[[3]])
  vardep <- all.vars(nlsformula[[2]])
  varindep <- intersect(all.vars(nlsformula[[3]]), colnames(newdata))
  
  ## vector of mean predictions on newdata with one bootstrap sample  
  one.mean.pred <- function(i)
  {
    do.call(f1, as.list(c(param[i,], newdata[varindep])))
  }
  boot.mean.pred <- sapply(1:niter, one.mean.pred)
  
  if (interval == "confidence")
  {
    recap.boot.mean.pred <- t(apply(boot.mean.pred, 1, 
                                    quantile, c(.5, .25, .75))) 
    colnames(recap.boot.mean.pred) <- c("Median", "25%", "75%")
    return(recap.boot.mean.pred)
  } else
  {
    ## vector of individual predictions on newdata with one bootstrap sample
    one.indiv.pred <- function(i)
    {
      boot.mean.pred[, i] + sample(scale(nlsresid, scale=FALSE), 
                                   size = nrow(newdata), replace=TRUE)
    }
    boot.indiv.pred <- sapply(1:niter, one.indiv.pred)
    recap.boot.indiv.pred <- t(apply(boot.indiv.pred, 1, 
                                     quantile, c(.5, .25, .75))) 
    colnames(recap.boot.indiv.pred) <- c("Median", "25%", "75%")
    return(recap.boot.indiv.pred)
  }
}
```

### plot_individual_prediction

```{r}
plot_individual_prediction <- function(imagery_type, raster_data, vector_data, dims) {
  
  # select current RGB imagery data
  rgb <- raster_data %>%
    filter(imagery == imagery_type)
  
  vector <- vector_data %>%
               filter(imagery == imagery_type)
  label <- paste('RTS IoU:', round(vector$rts_iou, 2))
  
  figure <- ggplot(data = vector) +
      geom_raster(data = rgb,
                  aes(x = x, y = y, fill = color_hex),
                  inherit.aes = FALSE) +
      scale_fill_manual(breaks = levels(input_data$color_hex),
                        values = levels(input_data$color_hex),
                        guide = 'none') +
      geom_sf(aes(geometry = val_geometry,
                  color = 'Validation',
                  linewidth = 'Validation'),
              fill = 'transparent') +
      scale_color_manual(name = '',
                         values = c('gray70'),
                         guide = guide_legend(order = 4)) +
      scale_linewidth_manual(name = '',
                             values = c(0.25),
                             guide = guide_legend(order = 4)) +
      new_scale('color') +
      new_scale('linewidth') +
      geom_sf(aes(geometry = rts_geometry,
                  color = 'Feature of\nInterest',
                  linewidth = 'Feature of\nInterest'),
              fill = 'transparent') +
      scale_color_manual(name = '',
                         values = c('gray90'),
                         drop = FALSE,
                         guide = guide_legend(order = 2)) +
      scale_linewidth_manual(name = '',
                             values = c(0.5),
                             guide = guide_legend(order = 2)) +
      new_scale('color') +
      new_scale('linewidth') +
      geom_sf(aes(geometry = mask_geometry,
                  color = 'Mask',
                  linewidth = 'Mask',
                  linetype = 'Mask'),
              fill = 'transparent') +
      scale_color_manual(name = '',
                         values = 'gray90',
                         drop = FALSE,
                         guide = guide_legend(order = 3)) +
      scale_linewidth_manual(name = '',
                             values = c(0.25),
                             guide = guide_legend(order = 3)) +
      scale_linetype_manual(name = '',
                            values = c('dashed'),
                            guide = guide_legend(order = 3)) +
      new_scale('color') +
      geom_sf(aes(geometry = pred_geometry,
                  color = pq_ci),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(name = 'Prediction\n(Quality)',
                         breaks = pq_labels,
                         labels = pq_labels,
                         values = pq_colors,
                         drop = FALSE,
                         guide = guide_legend(order = 1, nrow = 3)) +
    geom_label(x = dims$x_min + 110, 
               y = dims$y_min + 20, 
               label = label, 
               size = 2.5,
               label.padding = unit(0.1, 'lines'),
               label.r = unit(0, 'lines'),
               label.size = unit(0, 'lines')) +
    # facet_grid(. ~paste('RTS IoU:', round(rts_iou, 2))) +
    coord_sf(xlim = c(dims$x_min, dims$x_max),
             ylim = c(dims$y_min, dims$y_max),
             expand = FALSE) +
    # theme_few() +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          strip.text.y = element_text(size = 6),
          panel.grid = element_blank(),
          legend.position = 'bottom',
          plot.margin = margin(0, 0, 0, 0, "pt"))
  
  if (vector$id == '00000000000000000072') {
    figure <- figure +
      facet_grid(. ~ imagery)
  }
  
  return(figure)
}

```

### plot_prediction

```{r}
plot_prediction <- function(pid) {
  
  # get polygon data
  current_data <- polys %>%
    filter(id == pid) %>%
    select(imagery, id, status, rts_iou, pq_ci, pq_ci_size, bbox_geometry, 
           mask_geometry, rts_geometry, val_geometry, pred_geometry) %>%
    mutate(status = factor(status, levels = c('Active', 'General')))
  
  # prep RGB data
  current_rgb <- input_data %>%
    filter(id == pid) %>%
    full_join(current_data %>%
                select(id, imagery, rts_iou),
              by = c('imagery', 'id', 'rts_iou'))
  
  figure <- ggplot(data = current_data) +
    geom_raster(data = current_rgb,
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation',
                linewidth = 'Validation'),
            fill = 'transparent') +
    scale_color_manual(name = '',
                       values = c('gray70'),
                       guide = guide_legend(order = 4)) +
    scale_linewidth_manual(name = '',
                           values = c(0.25),
                       guide = guide_legend(order = 4)) +
    new_scale('color') +
    new_scale('linewidth') +
    geom_sf(aes(geometry = rts_geometry,
                color = 'Feature of Interest',
                linewidth = 'Feature of Interest'),
            fill = 'transparent') +
    scale_color_manual(name = '',
                       values = c('gray90'),
                       drop = FALSE,
                       guide = guide_legend(order = 2)) +
    scale_linewidth_manual(name = '',
                           values = c(0.5),
                       guide = guide_legend(order = 2)) +
    new_scale('color') +
    new_scale('linewidth') +
    geom_sf(aes(geometry = mask_geometry,
                color = 'Mask',
                linewidth = 'Mask',
                linetype = 'Mask'),
            fill = 'transparent') +
    scale_color_manual(name = '',
                       values = 'gray90',
                       drop = FALSE,
                       guide = guide_legend(order = 3)) +
    scale_linewidth_manual(name = '',
                           values = c(0.25),
                       guide = guide_legend(order = 3)) +
    scale_linetype_manual(name = '',
                          values = c('dashed'),
                       guide = guide_legend(order = 3)) +
    new_scale('color') +
    geom_sf(aes(geometry = pred_geometry,
                color = pq_ci),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = 'Prediction\n(Quality)',
                       breaks = pq_labels,
                       labels = pq_labels,
                       values = pq_colors,
                       drop = FALSE,
                       guide = guide_legend(order = 1, nrow = 3)) +
    facet_grid(
      paste('ID:', str_remove(id, "^0+")) ~ 
        imagery + paste('RTS IoU:', round(rts_iou, 2))
      ) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          legend.position = 'bottom')

  # print(figure)
  
  # ggsave(paste0('./figures/rts_features/', pid, '.pdf'),
  #        figure,
  #        height = 3,
  #        width = 6.5)

  return(figure)
  
}
```

### plot_prediction_2

```{r}
plot_prediction_2 <- function(pid, imagery_types, dims) {
  
  # get polygon data
  current_data <- polys %>%
    filter(id == pid) %>%
    select(imagery, id, status, rts_iou, pq_ci, pq_ci_size, bbox_geometry, 
           mask_geometry, rts_geometry, val_geometry, pred_geometry) %>%
    mutate(status = factor(status, levels = c('Active', 'General')))
  
  # prep RGB data
  current_rgb <- input_data %>%
    filter(id == pid) %>%
    full_join(current_data %>%
                select(id, imagery, rts_iou),
              by = c('imagery', 'id', 'rts_iou'))
  
  # get desired extent of current tile
  current_dims <- current_data %>%
    slice(1) %>%
    st_as_sf(crs = 3413) %>%
    bind_cols(map_dfr(.$rts_geometry, 
               ~ st_bbox(.x))) %>%
    mutate(x_min = (xmin + xmax)/2 - dims$x_spread_max/2,
           x_max = (xmin + xmax)/2 + dims$x_spread_max/2,
           y_min = (ymin + ymax)/2 - dims$y_spread_max/2,
           y_max = (ymin + ymax)/2 + dims$y_spread_max/2) %>%
    select(x_min, x_max, y_min, y_max)
  
  # make a map for each imagery type separately
  figures <- map(
    imagery_types,
    ~ plot_individual_prediction(.x, current_rgb, current_data, current_dims)
  )
  
  figure <- figures[[1]] | figures[[2]] | figures[[3]]

  return(figure)
  
}
```

### plot_zonal_stats

```{r, warning = FALSE}
plot_zonal_stats <- function(x_var, y_var, contrasts, limits) {
  
  predictor_name <- case_when(
    y_var == 'r_mean' ~ "expression('Red')",
    y_var == 'g_mean' ~ "expression('Green')",
    y_var == 'b_mean' ~ "expression('Blue')",
    y_var == 'lum_mean' ~ "expression('Luminance')",
    y_var == 'nir_mean' ~ "expression('NIR')",
    y_var == 'ndvi_mean' ~ "expression('NDVI')",
    y_var == 'ndwi_mean' ~ "expression('NDWI')",
    y_var == 'elev_mean' ~ "expression('Relative Elevation')",
    y_var == 'sr_mean' ~ "expression('Shaded Relief')",
    y_var == 'r_sd' ~ "expression(sigma ~ 'Red')",
    y_var == 'g_sd' ~ "expression(sigma ~ 'Green')",
    y_var == 'b_sd' ~ "expression(sigma ~ 'Blue')",
    y_var == 'lum_sd' ~ "expression(sigma ~ 'Luminance')",
    y_var == 'nir_sd' ~ "expression(sigma ~ 'NIR')",
    y_var == 'ndvi_sd' ~ "expression(sigma ~ 'NDVI')",
    y_var == 'ndwi_sd' ~ "expression(sigma ~ 'NDWI')",
    y_var == 'elev_sd' ~ "expression(sigma ~ 'Relative Elevation')",
    y_var == 'sr_sd' ~ "expression(sigma ~ 'Shaded Relief')"
  )
  
  rts_fig <- ggplot(zonal_stats %>%
                      filter(rts_class == 'RTS'), 
                    aes(x = .data[[x_var]], 
                        y = .data[[y_var]], 
                        color = .data[[x_var]])) +
    geom_boxplot(
      # outlier.shape = NA
      ) +
    geom_signif(data = contrasts %>%
                  filter(variable == y_var & rts_class == 'RTS'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label, group = contrast),
                stat="identity",
                manual = TRUE,
                tip_length = 0.1,
                inherit.aes = FALSE) +
    scale_y_continuous(eval(parse(text = predictor_name))) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme(axis.title.x = element_blank(),
          plot.margin = margin(0, 0, 0, 0, "pt")) +
    coord_cartesian(ylim = limits %>%
                      filter(variable == y_var & rts_class == 'RTS') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())

  delta_fig <- ggplot(zonal_stats %>%
                        filter(rts_class == 'Delta'), 
                      aes(x = .data[[x_var]], 
                          y = .data[[y_var]], 
                          color = .data[[x_var]])) +
    geom_boxplot(
      # outlier.shape = NA
      ) +
    geom_signif(data = contrasts %>%
                  filter(variable == y_var & rts_class == 'Delta'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label, group = contrast),
                stat="identity",
                manual = TRUE,
                inherit.aes = FALSE) +
    scale_x_discrete(name = 'Prediction Quality') +
    scale_y_continuous(eval(parse(text = predictor_name))) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme(axis.title.x = element_blank(),
          plot.margin = margin(0, 0, 0, 0, "pt")) +
    coord_cartesian(ylim = limits %>%
                      filter(variable == y_var & rts_class == 'Delta') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())
  
  bg_fig <- ggplot(zonal_stats %>%
                     filter(rts_class == 'Background'), 
                   aes(x = .data[[x_var]], 
                       y = .data[[y_var]], 
                       color = .data[[x_var]])) +
    geom_boxplot(
      # outlier.shape = NA
      ) +
    geom_signif(data = contrasts %>%
                  filter(variable == y_var & rts_class == 'Background'),
                aes(x = x_min, y = y, xend = x_max, yend = y,
                    annotation = star_label, group = contrast),
                stat="identity",
                manual = TRUE,
                inherit.aes = FALSE) +
    scale_x_discrete(name = 'Prediction Quality') +
    scale_y_continuous(eval(parse(text = predictor_name))) +
    scale_color_manual(values = pq_colors,
                       guide = 'none') +
    facet_grid(rts_class ~ imagery) +
    theme(plot.margin = margin(0, 0, 0, 0, "pt"))
    coord_cartesian(ylim = limits %>%
                      filter(variable == y_var & rts_class == 'Background') %>%
                      ungroup() %>%
                      select(lwr, upr) %>%
                      as_vector())

  zonal_stats_fig <- (
    rts_fig +
      theme(axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.title.y = element_blank())
  ) / (
    delta_fig +
      theme(strip.background.x = element_blank(),
            strip.text.x = element_blank(),
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank())
  ) / (
    bg_fig +
      theme(strip.background.x = element_blank(),
            strip.text.x = element_blank(),
            axis.title.y = element_blank())
  )
  
  return(zonal_stats_fig)
}
```

### pred_as_poly

```{r, include = FALSE}
pred_as_poly <- function(prediction, threshold = 0.5) {
  layer <- prediction[['prediction']]
  layer[layer >= threshold] <- 1
  layer[layer < threshold] <- 0
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = prediction) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'pred_bg',
                                tk_class == 1 ~ 'pred'),
           id = get_rast_id(prediction)) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('pred_geometry')
  if (!('pred_geometry' %in% colnames(poly))) {
    poly <- poly %>%
      mutate(pred_geometry = st_sfc(st_polygon(), crs = crs(prediction))) %>%
    st_set_geometry('pred_geometry')
  }
  
  return(poly)
}
```

### recall_precision

```{r, include = FALSE}
recall_precision <- function(truth, iou, thresholds) {
  
  df <- tibble(ground_truth = truth,
               iou_score = iou)
  precision <- c()
  recall <- c()
  
  for (threshold in thresholds) {
    pred_class <- if_else(iou >= threshold,
                          'positive',
                          'negative')
    
    df <- df %>%
      mutate(class = case_when(iou_score >= threshold & ground_truth == 1 ~ 'true positive',
                               iou_score >= threshold & ground_truth == 0 ~ 'false positive',
                               iou_score < threshold & ground_truth == 1 ~ 'false negative',
                               iou_score < threshold & ground_truth == 0 ~ 'true negative'))
    
    # precision = count(true positive)/(count(true positive) + count(false positive))
    precision <- c(precision,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false positive')))
                   )
    )
    
    # recall = count(true positive)/(count(true positive) + count(false negative))
    recall <- c(recall,
                   (
                     nrow(df %>%
                            filter(class == 'true positive')) /
                       (nrow(df %>%
                               filter(class == 'true positive')) 
                        + nrow(df %>%
                                 filter(class == 'false negative')))
                   )
    )
    
  }
  
  recall <- c(recall, 0)
  precision <- c(precision, 1)
  
  output <- tibble(recall = recall,
                   precision = precision,
                   threshold = threshold)
  
  return(output)
  
}
```

### trim_outliers

```{r, include = FALSE}
trim_outliers <- function(x) {
  x_quant <- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  x_iqr <- IQR(x, na.rm = TRUE)
  x_trim <- x[x <= x_quant['75%'] + x_iqr*1.5 & x >= x_quant['25%'] - x_iqr*1.5]
  return(x_trim)
}
```

### val_as_poly

```{r, include = FALSE}
val_as_poly <- function(prediction) {
  layer <- prediction[['validation']]
  layer <- classify(layer, 
                    matrix(c(0, 0,
                             1, 1),
                           ncol = 2,
                           byrow = TRUE))
  current_id <- get_rast_id(prediction)
  poly <- st_as_sf(as.polygons(layer, values = TRUE)) %>%
    rename(tk_class = validation) %>%
    mutate(tk_class = case_when(tk_class == 0 ~ 'val_bg',
                                tk_class == 1 ~ 'val'),
           id = current_id) %>%
    pivot_wider(names_from = 'tk_class',
                values_from = 'geometry',
                names_glue = '{tk_class}_geometry') %>%
    st_set_geometry('val_geometry')
  
  return(poly)
}
```

## Prep Plot Variables

```{r}
imagery_labels <- c('WorldView', 'PlanetScope', 'Sentinel-2')
imagery_labeller <- c('WorldView' = 'WorldView', 'PlanetScope' = 'PlanetScope', 'Sentinel-2' = 'Sentinel-2')
imagery_colors <- c('#FFCC00', '#0099AA', '#0000AA')

# prediction quality (pq)
pq_labels <- c('High', 'Expected', 'Low')
pq_colors <- c('#00CCFF', 'gray20', '#CC0000')
```


## Load Data

### Download Files

```{r}
loc_dir <- './data'
gd_dir <- 'data/DATA_V3_GEOTIFFS'
# maxar_pred_dir <- 'MAXAR20230623_161858_p25062023'
maxar_pred_dir <- 'MAXAR20230621_022422_p21062023'
planet_pred_dir <- 'PLANET20230621_190115_p21062023'
sentinel_pred_dir <- 'SENTINEL220230621_171002_p21062023'

gd_pred_folders <- drive_ls(paste0(gd_dir, '/TESTSET_INFERENCE')) %>%
  filter(name ==  maxar_pred_dir |
           name == planet_pred_dir |
           name == sentinel_pred_dir)

gd_maxar_input_folders <- drive_ls(paste0(gd_dir, '/MAXAR')) %>%
  filter(str_detect(name, 'valtest'))
gd_planet_input_folders <- drive_ls(paste0(gd_dir, '/PLANET')) %>%
  filter(str_detect(name, 'valtest'))
gd_sentinel_input_folders<- drive_ls(paste0(gd_dir, '/SENTINEL2')) %>%
  filter(str_detect(name, 'valtest'))
```

```{r}
# check if prediction files have already been downloaded
loc_filepaths <- list.files(loc_dir,
                            full.names = TRUE,
                            recursive = TRUE)

# WorldView
maxar_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(maxar_pred_dir))
]
maxar_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('maxar/(', 
                    gd_maxar_input_folders$name[1], '|', 
                    gd_maxar_input_folders$name[2], ')'))
]

# PlanetScope
planet_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(planet_pred_dir))
]
planet_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('planet/(', 
                    gd_planet_input_folders$name[1], '|', 
                    gd_planet_input_folders$name[2], ')'))
]

# Sentinel
sentinel_pred_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0(sentinel_pred_dir))
]
sentinel_input_files <- loc_filepaths[
  str_detect(loc_filepaths, 
             paste0('sentinel/(', 
                    gd_sentinel_input_folders$name[1], '|', 
                    gd_sentinel_input_folders$name[2], ')'))
]
```

```{r}
if (length(maxar_pred_files) == length(planet_pred_files) & 
    length(maxar_pred_files) == length(sentinel_pred_files) & 
    length(maxar_pred_files) > 0) {
  
  print(paste('There are', length(maxar_pred_files), 'prediction tiles.'))
  
} else {
  
  # download WorldView predictions
  maxar_pred_filepath <- paste0(loc_dir, '/maxar/predictions-', maxar_pred_dir)
  maxar_pred_files <- drive_ls(gd_pred_folders %>%
                                 filter(str_detect(name, 'MAXAR')),
                               pattern = 'tif$') %>%
    arrange(name)
  
  maxar_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, maxar_pred_filepath)
    )
  
  maxar_pred_files <- list.files(maxar_pred_filepath,
                                 pattern = 'tif$',
                                 full.names = TRUE)
  
  # download PlanetScope predictions
  planet_pred_filepath <- paste0(loc_dir, '/planet/predictions-', planet_pred_dir)
  planet_pred_files <- drive_ls(gd_pred_folders %>%
                                  filter(str_detect(name, 'PLANET')),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, planet_pred_filepath)
    )
  
  planet_pred_files <- list.files(planet_pred_filepath,
                                  pattern = 'tif$',
                                  full.names = TRUE)
  
  # download Sentinel-2 predictions
  sentinel_pred_filepath <- paste0(loc_dir, '/sentinel/predictions-', sentinel_pred_dir)
  sentinel_pred_files <- drive_ls(gd_pred_folders %>%
                                    filter(str_detect(name, 'SENTINEL2')),
                                  pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_pred_files %>%
    pmap(
      \(name, id, drive_resource, directory)
      googledrive_download(name, id, drive_resource, sentinel_pred_filepath)
    )
  
  sentinel_pred_files <- list.files(sentinel_pred_filepath,
                                    pattern = 'tif$',
                                    full.names = TRUE)
  
}

rm(gd_pred_folders)
```

```{r}
if (length(maxar_input_files) == length(planet_input_files) & 
    length(maxar_input_files) == length(sentinel_input_files) &
    length(maxar_input_files > 0)) {
  
  print(paste('There are', length(maxar_input_files), 'input data tiles.'))
  
} else {
  
  # Download WorldView Input Data Layers  
  maxar_input_filepaths <- paste0(loc_dir, '/maxar/', gd_maxar_input_folders$name)
  
  maxar_input_files <- drive_ls(gd_maxar_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  maxar_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, maxar_input_filepaths[1])
    )
  
  maxar_input_files <- drive_ls(gd_maxar_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  maxar_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, maxar_input_filepaths[2])
    )
  
  maxar_input_files <- map(maxar_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  maxar_input_files <- unlist(maxar_input_files)
  
  # Download PlanetScope Input Data Layers  
  planet_input_filepaths <- paste0(loc_dir, '/planet/', gd_planet_input_folders$name)
  
  planet_input_files <- drive_ls(gd_planet_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, planet_input_filepaths[1])
    )
  
  planet_input_files <- drive_ls(gd_planet_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  planet_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, planet_input_filepaths[2])
    )
  
  planet_input_files <- map(planet_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  planet_input_files <- unlist(planet_input_files)
  
  # Download sentinel Input Data Layers  
  sentinel_input_filepaths <- paste0(loc_dir, '/sentinel/', gd_sentinel_input_folders$name)
  
  sentinel_input_files <- drive_ls(gd_sentinel_input_folders %>%
                                  slice(1),
                                pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, sentinel_input_filepaths[1])
    )
  
  sentinel_input_files <- drive_ls(gd_sentinel_input_folders %>%
                                  slice(2),
                                pattern = 'tif$') %>%
    arrange(name)
  
  sentinel_input_files %>%
    pmap(
      \(name, id, drive_resource, directory) 
      googledrive_download(name, id, drive_resource, sentinel_input_filepaths[2])
    )
  
  sentinel_input_files <- map(sentinel_input_filepaths,
                           ~ list.files(.x,
                                        pattern = 'tif$',
                                        full.names = TRUE))
  sentinel_input_files <- unlist(sentinel_input_files)
  
}

rm(gd_maxar_input_folders, gd_planet_input_folders, gd_sentinel_input_folders)
```

### WorldView GeoTiffs

```{r, include = FALSE}
maxar_pred_dir_zscore <- 'MAXAR20230623_161858_p25062023'
maxar_pred_filepath_zscore <- paste0(loc_dir, '/maxar/predictions-', maxar_pred_dir_zscore)
maxar_pred_files_zscore <- list.files(maxar_pred_filepath_zscore,
                                 pattern = 'tif$',
                                 full.names = TRUE)

maxar_preds <- map(maxar_pred_files, ~ import_pred(.x))
maxar_preds_zscore <- map(maxar_pred_files_zscore, ~ import_pred(.x))

pred_ids <- map_chr(maxar_preds, ~ get_rast_id(.x))

### Remove this if we figure out the Active vs. General Duplicates
indices <- which(
    !(pred_ids %in% c("0000000000000000004a",
                      "0000000000000000004e", 
                      "0000000000000000004f",
                      "00000000000000000067",
                      "00000000000000000068",
                      "00000000000000000089"))
    )
pred_ids <- pred_ids[indices]

maxar_preds <- maxar_preds[indices]
maxar_preds_zscore <- maxar_preds_zscore[indices]

rm(maxar_pred_files)
```

```{r, include = FALSE}
maxar_input <- map(maxar_input_files, ~ rast(.x))
ids <- map_chr(maxar_input, ~ get_rast_id(.x))
names(maxar_input) <- ids

maxar_input <- filter_input_data(maxar_input, pred_ids)
rm(maxar_input_files, ids)
```


### PlanetScope GeoTiffs

```{r, include = FALSE}
planet_preds <- map(planet_pred_files, ~ import_pred(.x))

planet_preds <- planet_preds[indices]

rm(planet_pred_files)
```

```{r, include = FALSE}
planet_input <- map(planet_input_files, ~ rast(.x))
ids <- map_chr(planet_input, ~ get_rast_id(.x))
names(planet_input) <- ids

planet_input <- filter_input_data(planet_input, pred_ids)
rm(planet_input_files, ids)
```

### Sentinel GeoTiffs

```{r, include = FALSE}
sentinel_preds <- map(sentinel_pred_files, ~ import_pred(.x))

sentinel_preds <- sentinel_preds[indices]

rm(sentinel_pred_files)
```

```{r, include = FALSE}
sentinel_input <- map(sentinel_input_files, ~ rast(.x))
ids <- map_chr(sentinel_input, ~ get_rast_id(.x))
names(sentinel_input) <- ids

sentinel_input <- filter_input_data(sentinel_input, pred_ids)
rm(sentinel_input_files, ids)
```

### Polygons

```{r}
rts_outlines <- st_read('./data/rts_polygons/rts_polygons_for_Yili_May_2022_v2.shp') %>%
  st_transform(crs = 3413) %>%
  select(id = ID, region, status = Act_or_Gen, code_id, rts_area = Shape_Area, 
         Long, Lat) %>%
  mutate(
    rts_shape = as.numeric(4*pi*st_area(geometry)/st_perimeter(geometry)^2) # calculate Polsby-Popper value (shape compactness/roundness)
    )  %>%
  filter(id %in% pred_ids)
```

```{r}
gen_vs_act_tiles <- tibble(`Active` = c('4a', '4e', '4f', '67', '68', '89'),
                           `General` = c('25 (in validation not testing subset)', '28', '2c', '5e (in validation not testing subset)', '60 (in validation not testing subset)', '7f'))

knitr::kable(gen_vs_act_tiles, align = 'cc')
```

## Get Tile Bounding Boxes

```{r}
maxar_tiles <- maxar_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'WorldView') %>%
  select(id, imagery, bbox_geometry)

planet_tiles <- planet_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'PlanetScope') %>%
  select(id, imagery, bbox_geometry)

sentinel_tiles <- sentinel_preds %>%
  map_dfr(~ bbox(.x)) %>%
  mutate(imagery = 'Sentinel-2') %>%
  select(id, imagery, bbox_geometry)

tiles <- maxar_tiles %>%
  rbind.data.frame(planet_tiles) %>%
  rbind.data.frame(sentinel_tiles)

rm(maxar_tiles, planet_tiles, sentinel_tiles)
```

```{r}
polys <- tiles %>%
  left_join(rts_outlines %>%
              st_transform(crs = 3413) %>%
              as_tibble() %>%
              rename(rts_geometry = geometry), 
            by = 'id') %>%
  st_as_sf(crs = st_crs(rts_outlines))

rm(tiles)
```


## Convert Predictions to Vector

```{r}
maxar_pred_polys <- maxar_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x
      )
    ) %>%
  mutate(imagery = 'WorldView')

maxar_pred_polys_zscore <- maxar_preds_zscore %>%
  map_dfr(
    ~ pred_as_poly(
      .x
      )
    ) %>%
  mutate(imagery = 'WorldView')

planet_pred_polys <- planet_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x
      )
    ) %>%
  mutate(imagery = 'PlanetScope')

sentinel_pred_polys <- sentinel_preds %>%
  map_dfr(
    ~ pred_as_poly(
      .x#, sentinel_rts_threshold
      )
    ) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Prediction Polygons into `polys` SF Dataframe

```{r}
pred_polys <- maxar_pred_polys %>%
  rbind(planet_pred_polys) %>%
  rbind(sentinel_pred_polys)

polys <- polys %>%
  full_join(pred_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_pred_polys, planet_pred_polys, sentinel_pred_polys, pred_polys)
```


## Convert Validation to Vector

```{r}
maxar_val_polys <- maxar_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'WorldView')

planet_val_polys <- planet_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'PlanetScope')

sentinel_val_polys <- sentinel_preds %>%
  map_dfr(~ val_as_poly(.x)) %>%
  mutate(imagery = 'Sentinel-2')
```

Join Validation Polygons into `polys` SF Dataframe

```{r}
val_polys <- maxar_val_polys %>%
  rbind(planet_val_polys) %>%
  rbind(sentinel_val_polys)

polys <- polys %>%
  full_join(val_polys %>%
              as_tibble(),
            by = c('id', 'imagery'))

rm(maxar_val_polys, planet_val_polys, sentinel_val_polys, val_polys)
```


## Create AOI Masks for Tiles

This allows the inclusion of RTS features that are in tiles with multiple features, by masking out areas associated with RTS features that are not the feature of interest

```{r}
maxar_masks <- maxar_input %>%
  map(~ feature_mask(.x, rts_outlines))

planet_masks <- planet_input %>%
          map(~ feature_mask(.x, rts_outlines))

sentinel_masks <- sentinel_input %>%
          map(~ feature_mask(.x, rts_outlines))

masks <- maxar_masks %>%
  map2_dfr(pred_ids, ~ mask_as_df(.x, .y)) %>%
  mutate(imagery = 'WorldView') %>%
  rbind(planet_masks %>%
          map2_dfr(pred_ids, ~ mask_as_df(.x, .y)) %>%
          mutate(imagery = 'PlanetScope')) %>%
  rbind(sentinel_masks %>%
          map2_dfr(pred_ids, ~ mask_as_df(.x, .y)) %>%
          mutate(imagery = 'Sentinel-2'))

masks_df <- pmap(list(maxar_masks, pred_ids),
                 \(a, b) (as.data.frame(a, xy = TRUE) %>%
                            mutate(imagery = 'WorldView',
                                   id = b) %>%
                            select(imagery, id, x, y, mask = layer))) %>%
  list_rbind() %>%
  rbind(pmap(list(planet_masks, pred_ids),
             \(a, b) (as.data.frame(a, xy = TRUE) %>%
                        mutate(imagery = 'PlanetScope',
                               id = b) %>%
                        select(imagery, id, x, y, mask = layer))) %>%
          list_rbind()) %>%
  rbind(pmap(list(sentinel_masks, pred_ids),
             \(a, b) (as.data.frame(a, xy = TRUE) %>%
                        mutate(imagery = 'Sentinel-2',
                               id = b) %>%
                        select(imagery, id, x, y, mask = layer))) %>%
          list_rbind()) %>%
  mutate(imagery = factor(
    imagery,
    levels = c('WorldView', 'PlanetScope', 'Sentinel-2')
  ))
```

```{r}
polys <- polys %>%
  left_join(masks %>%
              as_tibble() %>%
              select(imagery, id, mask_geometry = geometry),
            by = c('imagery', 'id')) %>%
  mutate(pred_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                             mask_geometry), 
                                        ~ st_intersection(...)),
                                   crs = crs(polys)),
         pred_bg_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                                 mask_geometry), 
                                            ~ st_intersection(...)),
                                       crs = crs(polys)),
         val_mask_geometry = st_as_sfc(pmap(list(val_geometry, 
                                                 mask_geometry), 
                                            ~ st_intersection(...)),
                                       crs = crs(polys)),
         val_bg_mask_geometry = st_as_sfc(pmap(list(val_bg_geometry, 
                                                    mask_geometry), 
                                               ~ st_intersection(...)),
                                          crs = crs(polys)),
         imagery = factor(imagery,
                          levels = c('WorldView', 'PlanetScope', 'Sentinel-2')))
rm(masks)
```


## Add Region Info to `polys`

Get Country Data for Mapping

```{r}
crop_poly <- tibble(geometry = st_sfc(st_point(c(0, 90)),
                                      crs = 'EPSG:4326')) %>%
  st_sf() %>%
  st_transform(crs = st_crs(polys)) %>%
  st_buffer(dist = 3909167) %>%
  smoothr::densify(n = 3) %>%
  st_transform(crs = 'EPSG:4326')

arctic_circle <- tibble(lon = c(-180,180),
                    lat = c(66, 66)) %>%
  st_as_sf(coords = c("lon","lat"),
           crs = "EPSG:4326") %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("LINESTRING") %>% 
  smoothr::densify(max_distance = 1)

world_north <- world %>%
  st_intersection(crop_poly) %>%
  st_transform(crs = st_crs(polys)) %>%
  select(name_long, continent, region_un, subregion)

world_north <- world_north %>%
  st_union(by_feature = TRUE)
  
world_north_buffer <- world_north %>%
  st_buffer(50000)

if (!('name_long' %in% colnames(polys))) {
  
  polys <- polys %>%
  st_join(world_north_buffer)
  
}


long_lines_from_coords <- function(lon, lat_min, lat_max) {
  line <- expand_grid(lon = lon,
                      lat = c(lat_min, lat_max)) %>%
    st_as_sf(coords = c("lon","lat"),
             crs = "EPSG:4326") %>%
    summarise(geometry = st_combine(geometry)) %>%
    st_cast("LINESTRING") %>% 
    smoothr::densify(max_distance = 1) %>%
    mutate(label = lon)
  
  return(line)
}

long_lines <- seq(-180, 180, by = 60) %>%
  map(~ long_lines_from_coords(.x, lat_min = 55, lat_max = 90)) %>%
  bind_rows()

lat_lines_from_coords <- function(lat, lon_min, lon_max) {
  line <- expand_grid(lon = c(lon_min, lon_max),
                      lat = lat) %>%
    st_as_sf(coords = c("lon","lat"),
             crs = "EPSG:4326") %>%
    summarise(geometry = st_combine(geometry)) %>%
    st_cast("LINESTRING") %>% 
    smoothr::densify(max_distance = 1) %>%
    mutate(label = lat)
  
  return(line)
}

lat_lines <- seq(60, 90, by = 10) %>%
  map(~ lat_lines_from_coords(.x, lon_min = -180, lon_max = 180)) %>%
  bind_rows()
```

Hard Code Regions by Longitude

```{r}
polys <- polys %>%
  mutate(region = factor(case_when(Long < -135 & Long > -140 ~ 'Herschel Island',
                            Long < -130 & Long > -135 ~ 'Tuktoyaktuk',
                            Long < -125 & Long > -130 ~ 'Horton Delta',
                            Long < -110 & Long > -125 ~ 'Banks Island',
                            Long > 60 & Long < 80 ~ 'Yamal/Gydan',
                            TRUE ~ 'Other'),
                         levels = c('Herschel Island',
                                    'Tuktoyaktuk',
                                    'Horton Delta',
                                    'Banks Island',
                                    'Yamal/Gydan')),
         yg = case_when(Long > 60 & Long < 80 ~ 'Yamal/Gydan',
                        TRUE ~ 'Other'),
         banks = case_when(Long < -100 & Long > -125 ~ 'Banks Island',
                                  TRUE ~ 'Other'))
```

```{r, fig.height = 3.6, fig.width = 5}
site_map <- ggplot(world_north) +
  geom_sf(data = long_lines,
          color = 'gray90',
          linewidth = 0.25) +
  geom_sf(data = lat_lines,
          color = 'gray90',
          linewidth = 0.25) +
  geom_sf(data = crop_poly,
          color = 'transparent',
          fill = 'gray90',
          alpha = 0.5) +
  geom_sf(color = 'black', 
          fill = 'gray80') +
  geom_sf(data = polys,
          aes(geometry = rts_geometry, color = region, fill = region),
          linewidth = 1,
          inherit.aes = FALSE) +
  geom_sf(data = crop_poly, 
          color = 'gray70',
          fill = 'transparent',
          linewidth = 0.5,
          inherit.aes = FALSE) +
  geom_sf(data = arctic_circle, 
          color = 'gray50',
          linetype = 'dashed',
          linewidth = 0.25,
          inherit.aes = FALSE) +
  scale_color_viridis(name = 'Region',
                      discrete = TRUE) +
  scale_fill_viridis(name = 'Region',
                      discrete = TRUE) +
  # geom_text()
  theme_void()

site_map

# ggsave('./figures/site_map.pdf',
#        site_map,
#        height = 3.6,
#        width = 5)
# ggsave('./figures/site_map.jpg',
#        site_map,
#        height = 3.6,
#        width = 5)
```


## Convert Input Data to DF

```{r}
input_data <- pmap(list(x = maxar_input, 
                        y = maxar_preds),
                   \(x, y) input_as_df(x, y)) %>%
  list_rbind() %>%
  mutate(imagery = 'WorldView') %>%
  rbind(
    pmap(list(x = planet_input, 
              y = planet_preds),
         \(x, y) input_as_df(x, y)) %>%
      list_rbind() %>%
      mutate(imagery = 'PlanetScope')
  ) %>%
  rbind(
    pmap(list(x = sentinel_input, 
              y = sentinel_preds),
         \(x, y) input_as_df(x, y)) %>%
      list_rbind() %>%
      mutate(imagery = 'Sentinel-2')
  ) %>%
  mutate(imagery = factor(
    imagery,
    levels = c('WorldView', 'PlanetScope', 'Sentinel-2'))
    ) %>%
  select(imagery, id, rts_class, x, y, 
         r, g, b, lum, nir, ndvi, ndwi, elev, sr, 
         r_stretch, g_stretch, b_stretch, color_hex, prediction)
```


## Interactive Map of Features

```{r}
pal_viridis <- colorFactor("viridis", polys$imagery)

leaflet() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  addPolygons(data = polys %>%
                select(imagery, pred_geometry) %>%
                st_transform(crs = 4326), 
              color = ~ pal_viridis(imagery),
              fill = FALSE,
              weight = 2) %>%
  addLegend(data = polys, 
            pal = pal_viridis, 
            values = ~ imagery) %>%
  addPolygons(data = polys %>%
                select(val_geometry) %>%
                st_transform(crs = 4326), 
              color = 'black',
              fill = FALSE,
              weight = 2)
```

## IoU

### Calculate IoU

```{r}
polys <- polys %>%
  mutate(rts_int_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                                val_mask_geometry), 
                                           ~ st_intersection(...)),
                                  crs = crs(polys)),
         rts_uni_geometry = st_as_sfc(pmap(list(pred_geometry, 
                                                val_mask_geometry), 
                                           ~ st_union(...)),
                                  crs = crs(polys)),
         bg_int_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                               val_bg_mask_geometry), 
                                          ~ st_intersection(...)),
                                  crs = crs(polys)),
         bg_uni_geometry = st_as_sfc(pmap(list(pred_bg_geometry, 
                                               val_bg_mask_geometry), 
                                          ~ st_union(...)),
                                  crs = crs(polys)))
```

IoU (Calculated in Model)

|Imagery (normalization method)|Test IoU|Val IoU|
|:---:|:---:|:---:|
|WorldView (0-1)|0.75|0.69|
|WorldView (z-score)|0.73|0.72|
|PlanetScope (0-1)|0.71|0.70|
|Sentinel-2 (0-1)|0.68|0.66|


```{r}
polys <- polys %>%
  mutate(rts_iou = as.numeric(st_area(rts_int_geometry)/st_area(rts_uni_geometry)),
         bg_iou = as.numeric(st_area(bg_int_geometry)/st_area(bg_uni_geometry)),
         mean_iou = (rts_iou + bg_iou)/2,
         mean_iou_v2 = case_when(
           st_is_empty(pred_geometry) ~ bg_iou,
           TRUE ~ (rts_iou + bg_iou)/2
         ))
```

```{r}
iou <- polys %>%
  as_tibble() %>%
  summarise(rts_iou = round(mean(rts_iou), 2),
            mean_iou = round(mean(mean_iou), 2),
            mean_iou_v2 = round(mean(mean_iou_v2), 2),
            .by = 'imagery') %>%
  select(Imagery = imagery, `RTS IoU` = rts_iou, `Val IoU` = mean_iou, `Val IoU (remove zeros)` = mean_iou_v2)
knitr::kable(iou, caption = 'IoU (Calculated Directly from Predictions)')
```

### Plot

```{r, fig.width = 4, fig.height = 4}
imagery_performance_summary <- polys %>%
  as_tibble() %>%
  summarise(rts_iou_mean = mean(rts_iou),
            rts_iou_median = median(rts_iou),
            rts_iou_sd = sd(rts_iou),
            mean_iou_median = median(mean_iou),
            mean_iou_sd = sd(mean_iou),
            .by = imagery)

ggplot(polys,
       aes(x = rts_iou, fill = imagery)) +
  geom_histogram(binwidth = 0.05,
                 boundary = 0) +
  geom_vline(data = imagery_performance_summary,
             aes(xintercept = rts_iou_median, linetype = 'Median')) +
  geom_vline(data = imagery_performance_summary,
             aes(xintercept = rts_iou_mean, linetype = 'Mean')) +
  # geom_vline(data = imagery_performance_summary,
  #            aes(xintercept = rts_iou_median - rts_iou_sd),
  #            linetype = 'dotted') +
  # geom_vline(data = imagery_performance_summary,
  #            aes(xintercept = rts_iou_median + rts_iou_sd),
  #            linetype = 'dotted') +
  # geom_vline(data = imagery_performance_summary,
  #            aes(xintercept = rts_iou_median + 2*rts_iou_sd),
  #            linetype = 'dotted') +
  scale_x_continuous(name = 'RTS IoU',
                     minor_breaks = seq(0, 0.95, by = 0.05)) +
  scale_y_continuous(name = 'Count') +
  scale_fill_manual(values = imagery_colors) +
  scale_linetype_manual(values = c('solid', 'dashed')) +
  facet_grid(imagery ~ .) +
  theme(legend.title = element_blank())

# ggsave('./figures/iou_hist.pdf',
#        height = 4,
#        width = 4)
# ggsave('./figures/iou_hist.jpg',
#        height = 4,
#        width = 4)

knitr::kable(imagery_performance_summary)
```


## Performance by Feature Size

### Size Distribution by Region

```{r, include = FALSE}
rts_area_hist <- ggplot(polys, aes(x = rts_area, fill = yg)) +
  geom_density(alpha = 0.9) +
  scale_fill_manual(name = 'Region',
                    values = c('white', 'black')) +
  scale_x_log10(name = expression('RTS Area (m'^2*')'),
                labels = scales::label_number(big.mark = ''),
                minor_breaks = c(seq(100, 900, by = 100),
                           seq(1000, 9000, by = 1000),
                           seq(10000, 90000, by = 10000),
                           seq(100000, 200000, by = 100000))) +
  scale_y_continuous(name = 'Density')
rts_area_hist

# ggsave('./figures/rts_area_hist.pdf',
#        rts_area_hist,
#        width = 6.5,
#        height = 3)
# ggsave('./figures/rts_area_hist.jpg',
#        rts_area_hist,
#        width = 6.5,
#        height = 3)
```

```{r, include = FALSE}
arrows <- tibble(
  xmin = c(
    min(polys$rts_shape) + 0.0625*(max(polys$rts_shape) - min(polys$rts_shape)),
    max(polys$rts_shape) - 0.0625*(max(polys$rts_shape) - min(polys$rts_shape))
    ),
  xmax = c(
    min(polys$rts_shape),
    max(polys$rts_shape)
    ),
  y = rep(-0.85, 2),
  label = c('Less Compact', 'More Compact')
  )

rts_shape_hist <- ggplot(polys, aes(x = rts_shape, fill = yg)) +
  geom_density(alpha = 0.9) +
  annotate(
    'segment',
    x = arrows$xmin, xend = arrows$xmax,
    y = arrows$y, yend = arrows$y,
    arrow = arrow(length = unit(0.3, 'cm'))
  ) +
  annotate(
    'text',
    x = arrows$xmin + c(0.01, -0.01),
    y = arrows$y,
    label = arrows$label,
    size = 3,
    hjust = c(0, 1)
  ) +
  scale_fill_manual(name = 'Region',
                    values = c('white', 'black')) +
  scale_x_continuous(name = expression('RTS Shape')) +
  scale_y_continuous(name = 'Density') +
  coord_cartesian(clip = 'off',
                  ylim = c(0, 2.55))
rts_shape_hist

# ggsave('./figures/rts_shape_hist.pdf',
#        rts_shape_hist,
#        width = 6.5,
#        height = 3)
# ggsave('./figures/rts_shape_hist.jpg',
#        rts_shape_hist,
#        width = 6.5,
#        height = 3)
```

```{r, fig.height = 4, fig.width = 6.5}
rts_area_shape_hist <- rts_area_hist  /
  rts_shape_hist +
    plot_layout(guides = 'collect') & theme(legend.position = 'bottom')
rts_area_shape_hist
# ggsave('./figures/rts_area_shape_hist.pdf',
#        rts_area_shape_hist,
#        width = 6.5,
#        height = 4)
# ggsave('./figures/rts_area_shape_hist.jpg',
#        rts_area_shape_hist,
#        width = 6.5,
#        height = 4)
```

```{r}
rts_summaries <- polys %>%
  as_tibble() %>%
  summarise(mean_size = mean(rts_area),
            min_size = min(rts_area),
            max_size = max(rts_area),
            median_size = median(rts_area),
            .by = 'yg')
knitr::kable(rts_summaries)
```

### `nls` Models

Run `nls` models and bootstrap parameters

```{r}
# maxar_iou_nls <- nls(rts_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'WorldView'))
# 
# maxar_iou_boot <- nlsBoot(maxar_iou_nls, 500000)
# saveRDS(maxar_iou_nls, './data/models/maxar_iou_nls.RData')
# saveRDS(maxar_iou_boot, './data/models/maxar_iou_boot.RData')

maxar_iou_nls <- readRDS('./data/models/maxar_iou_nls.RData')
maxar_iou_boot <- readRDS('./data/models/maxar_iou_boot.RData')
summary(maxar_iou_nls)
```

```{r}
# planet_iou_nls <- nls(rts_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'PlanetScope'))
# 
# planet_iou_boot <- nlsBoot(planet_iou_nls, 500000)
# saveRDS(planet_iou_nls, './data/models/planet_iou_nls.RData')
# saveRDS(planet_iou_boot, './data/models/planet_iou_boot.RData')

planet_iou_nls <- readRDS('./data/models/planet_iou_nls.RData')
planet_iou_boot <- readRDS('./data/models/planet_iou_boot.RData')
summary(planet_iou_nls)
```

```{r}
# sentinel_iou_nls <- nls(rts_iou ~ Vmax * rts_area / (Km + rts_area),
#                start = list(Km = 50, Vmax = 2),
#                data = polys %>%
#                  filter(imagery == 'Sentinel-2'))
# 
# sentinel_iou_boot <- nlsBoot(sentinel_iou_nls, 500000)
# saveRDS(sentinel_iou_nls, './data/models/sentinel_iou_nls.RData')
# saveRDS(sentinel_iou_boot, './data/models/sentinel_iou_boot.RData')

sentinel_iou_nls <- readRDS('./data/models/sentinel_iou_nls.RData')
sentinel_iou_boot <- readRDS('./data/models/sentinel_iou_boot.RData')
summary(sentinel_iou_nls)
```

Table for nls model summaries

```{r}
rts_iou_summary <- tidy(maxar_iou_nls) %>%
  mutate(Imagery = 'WorldView') %>%
  rbind(tidy(planet_iou_nls) %>%
          mutate(Imagery = 'PlanetScope')) %>%
  rbind(tidy(sentinel_iou_nls) %>%
          mutate(Imagery = 'Sentinel-2')) %>%
  mutate(across(estimate:p.value, ~ round(.x, 3)),
         p.value = case_when(p.value == 0 ~ '<0.001',
                             p.value > 0 ~ as.character(p.value))) %>%
  select(Imagery, Term = term, Estimate = estimate, SE = std.error, 
         `t-statistic` = statistic, `p-value` = p.value)

# write.csv(rts_iou_summary,
#           './tables/iou_size_nls.csv',
#           row.names = FALSE)

knitr::kable(rts_iou_summary)
```

Bootstrap predictions for plotting the `nls` models

```{r}
newdata <- tibble(rts_area = seq(min(polys$rts_area), max(polys$rts_area), length.out = 200))
newdata2 <- tibble(rts_area = c(min(polys$rts_area),
                                seq(ceiling(min(polys$rts_area)/100)*100, 
                                    ceiling(max(polys$rts_area)/100)*100, 
                                    by = 100),
                                max(polys$rts_area)))
```

```{r}
# maxar_iou_predict <- my_nlsBootPredict(maxar_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(maxar_iou_predict, './data/models/maxar_iou_predict.RData')

maxar_iou_predict <- readRDS('./data/models/maxar_iou_predict.RData')
maxar_iou_ci <- newdata %>%
  cbind(maxar_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `25%`, upr = `75%`)
```

```{r}
# planet_iou_predict <- my_nlsBootPredict(planet_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(planet_iou_predict, './data/models/planet_iou_predict.RData')

planet_iou_predict <- readRDS('./data/models/planet_iou_predict.RData')
planet_iou_ci <- newdata %>%
  cbind(planet_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `25%`, upr = `75%`)
```

```{r}
# sentinel_iou_predict <- my_nlsBootPredict(sentinel_iou_boot, newdata = newdata, interval = 'prediction')
# saveRDS(sentinel_iou_predict, './data/models/sentinel_iou_predict.RData')

sentinel_iou_predict <- readRDS('./data/models/sentinel_iou_predict.RData')
sentinel_iou_ci <- newdata %>%
  cbind(sentinel_iou_predict %>%
          as_tibble()) %>%
  select(rts_area, prediction = Median, lwr = `25%`, upr = `75%`)
```

Add predictions to `polys` to use in prediction quality calculation

```{r}
# Add predictions to `polys`
iou_predictions <- rbind(
  my_nlsBootPredict(maxar_iou_boot, 
                    polys %>%
                      as_tibble() %>%
                      filter(imagery == 'WorldView'),
                    interval = 'prediction'),
  my_nlsBootPredict(planet_iou_boot, 
                    polys %>%
                      as_tibble() %>%
                      filter(imagery == 'PlanetScope'),
                    interval = 'prediction'),
  my_nlsBootPredict(sentinel_iou_boot, 
                    polys %>%
                      as_tibble() %>%
                      filter(imagery == 'Sentinel-2'),
                    interval = 'prediction')
  )

polys <- polys %>%
  mutate(
    iou_pred = iou_predictions[, 1],
    iou_pred_lwr = iou_predictions[, 2],
    iou_pred_upr = iou_predictions[, 3]
  )
```

### Plot

```{r}
iou_ci <- maxar_iou_ci %>%
  mutate(imagery = 'WorldView') %>%
  rbind(planet_iou_ci %>%
          mutate(imagery = 'PlanetScope')) %>%
  rbind(sentinel_iou_ci %>%
          mutate(imagery = 'Sentinel-2')) %>%
  mutate(imagery = factor(imagery,
                          levels = c('WorldView', 'PlanetScope', 'Sentinel-2')))

rm(maxar_iou_ci, planet_iou_ci, sentinel_iou_ci, newdata)
```

```{r}
ggplot(polys, aes(x = rts_area, y = rts_iou, color = imagery)) +
  geom_point(size = 1) +
  geom_ribbon(data = iou_ci,
            aes(x = rts_area, ymin = lwr, ymax = upr, group = imagery),
            alpha = 0.2,
            inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU',
                     limits = c(0, 1)) +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels) +
  theme(legend.title = element_blank())
```


## Undetected Features

```{r}
knitr::kable(
  polys %>%
    as_tibble() %>%
    filter(rts_iou == 0) %>%
    summarise(missed_feature_count = n(),
              max_area = max(rts_area),
              .by = 'imagery')
)

knitr::kable(
  polys %>%
    as_tibble() %>%
    summarise(missed_feature_count = n(),
              .by = c('imagery', 'yg'))
)

knitr::kable(
  polys %>%
    as_tibble() %>%
    filter(rts_iou == 0) %>%
    summarise(missed_feature_count = n(),
              .by = c('imagery', 'yg'))
)
```


## Active vs. General RTS Performance

```{r}
iou_by_rts_status <- polys %>%
  as_tibble() %>%
  summarise(mean_iou = mean(mean_iou),
            rts_iou = mean(rts_iou),
            .by = c(imagery, status))
```

```{r}
rts_status_lm <- lm(rts_iou ~ imagery * status,
                             data = polys)
rts_status_contrasts <- emmeans(rts_status_lm,
        pairwise ~ status | imagery,
        adjust = 'tukey')

rts_status_pvalues <- tibble(
  imagery = summary(rts_status_contrasts)$contrasts$imagery,
  p_val = summary(rts_status_contrasts)$contrasts$p.value,
  x_pos = rep(1.5, 3),
  star_y_pos = rep(0.9, 3),
  label_y_pos = rep(0.95, 3)
) %>%
  mutate(p_label = paste0('p-value = ', round(p_val, 3)),
         star_label = assign_conf_stars(p_val))
knitr::kable(rts_status_pvalues)
```

### Plot

It is possible to get rid of the inner panel borders, if I decide that looks better: <https://stackoverflow.com/questions/46220242/ggplot2-outside-panel-border-when-using-facet>

```{r}
ggplot(polys, 
       aes(x = status, 
           y = rts_iou, 
           group = interaction(imagery, status))) +
  geom_point(position = position_jitterdodge(seed = 1, 
                                             dodge.width = 0.9, 
                                             jitter.width = 0.5),
             aes(color = imagery),
             size = 1,
             alpha = 0.1) +
  geom_violin(aes(color = imagery),
              fill = 'gray60',
              linewidth = 0.75,
              alpha = 0.4,
              draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_text(data = rts_status_pvalues,
            aes(x = x_pos, y = star_y_pos, label = star_label),
            inherit.aes = FALSE) +
  # geom_text(data = rts_status_pvalues,
  #           aes(x = x_pos, y = label_y_pos, label = p_label),
  #           inherit.aes = FALSE) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_color_manual(values = imagery_colors,
                     labels = imagery_labels,
                     guide = 'none') +
  facet_wrap(~ imagery, 
             strip.position = 'bottom', 
             scales = 'free_x',
             labeller = labeller(imagery = imagery_labeller)) +
  theme(axis.title.x = element_blank(),
        legend.title = element_blank(),
        panel.spacing = unit(0, "lines"), 
        strip.background = element_blank(),
        strip.placement = "outside")
```

## Drivers of Unexpected RTS Prediction Performance

### Classify Features Using Confidence Interval Approach

This approach first uses the 50% CI of the model parameters to determine whether RTS features were predicted better or worse than expected based on the model. Next, the threshold at which RTS size doesn't impact IoU is determined from where the slope of the model approaches 0 (currently using slope < 1e-06) for each imagery type. RTS features smaller than this threshold that were predicted better than expected are analyzed later to determine why some small RTS can be identified from the imagery.


```{r, include = FALSE}
# take the derivative of the non-linear function to find where the slope approaches 0
# get parameters from `summary({model})$parameters`
maxar_d1 <- D(expression(y = 0.8064456 * x / (3089.6118432 + x)), name = 'x')
planet_d1 <- D(expression(y = 0.7622447 * x / (3940.7125511 + x)), name = 'x')
sentinel_d1 <- D(expression(y = 0.6637391 * x / (3750.5895223 + x)), name = 'x')

# estimate where the derivative crosses 1e-05
estimate_grid <- tibble(rts_area = seq(10000, 70000, by = 0.1))

maxar_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(maxar_d1, rts_area))
planet_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(planet_d1, rts_area))
sentinel_est <- estimate_grid %>%
  mutate(slope_est = eval_expression(sentinel_d1, rts_area))

maxar_cross <- maxar_est %>%
  slice(which.min(abs(1e-05-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-05
planet_cross <- planet_est %>%
  slice(which.min(abs(1e-05-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-05
sentinel_cross <- sentinel_est %>%
  slice(which.min(abs(1e-05-slope_est))) %>%
  select(rts_area) %>%
  as.numeric() # find closest to 1e-05

size_thresholds <- tibble(imagery = c('WorldView', 'PlanetScope', 'Sentinel-2'),
                          rts_threshold = c(maxar_cross, 
                                            planet_cross, 
                                            sentinel_cross))
rm(maxar_d1, planet_d1, sentinel_d1,
   maxar_est, planet_est, sentinel_est,
   maxar_cross, planet_cross, sentinel_cross,
   estimate_grid)
```

```{r}
rts_iou_thresholds <- polys %>%
  as_tibble() %>%
  summarise(rts_iou_mean = mean(rts_iou),
            rts_sd = sd(rts_iou),
            .by = imagery) %>%
  mutate(rts_iou_threshold = rts_iou_mean)

polys <- polys %>%
  mutate(
    size_threshold = case_when(
      imagery == 'WorldView' ~ 
        filter(size_thresholds, imagery == 'WorldView')$rts_threshold,
      imagery == 'PlanetScope' ~ 
        filter(size_thresholds, imagery == 'PlanetScope')$rts_threshold,
      imagery == 'Sentinel-2' ~ 
        filter(size_thresholds, imagery == 'Sentinel-2')$rts_threshold
    ),
    iou_threshold = case_when(
      imagery == 'WorldView' ~ 
        filter(rts_iou_thresholds, imagery == 'WorldView')$rts_iou_threshold,
      imagery == 'PlanetScope' ~ 
        filter(rts_iou_thresholds, imagery == 'PlanetScope')$rts_iou_threshold,
      imagery == 'Sentinel-2' ~ 
        filter(rts_iou_thresholds, imagery == 'Sentinel-2')$rts_iou_threshold
    ),
    pq_ci = factor(
      case_when(
        rts_iou > iou_pred_upr & rts_iou > iou_threshold ~ 'High',
        rts_iou < iou_pred_lwr ~ 'Low',
        TRUE ~ 'Expected'
      ),
      levels = c('High', 'Expected', 'Low')),
    pq_ci_size = factor(
      case_when(
        rts_iou > iou_pred_upr & rts_iou > iou_threshold & 
          rts_area <= size_threshold ~ 'High',
        rts_iou < iou_pred_lwr & rts_area > size_threshold ~ 'Low',
        TRUE ~ 'Expected'
      ),
      levels = c('High', 'Expected', 'Low'))
  )
```

Size at which predicted RTS IoU is higher than the median RTS IoU

```{r}
min_rts_area <- iou_ci %>%
  left_join(polys %>%
              as_tibble() %>%
              summarise(rts_iou_median = median(rts_iou), 
                        .by = imagery) %>%
              select(imagery, rts_iou_median),
            by = 'imagery') %>%
  filter(
    abs(prediction - rts_iou_median) == min(abs(prediction - rts_iou_median)),
         .by = imagery
    ) %>%
  left_join(size_thresholds %>%
              mutate(rts_threshold = ceiling(rts_threshold/100)*100),
            by = 'imagery') %>%
  mutate(rts_iou_median = round(rts_iou_median, 2),
         rts_area_exceed_median = ceiling(rts_area/100)*100) %>%
  select(-rts_area) %>%
  left_join(iou_ci %>%
              filter(prediction > 0.5, .by = imagery) %>%
              summarise(rts_area = first(rts_area), 
                        .by = imagery),
            by = 'imagery') %>%
  mutate(rts_area_exceed_0.5 = ceiling(rts_area/100)*100) %>%
  select(`Imagery` = imagery, 
         `Median RTS IoU` = rts_iou_median,
         `RTS Area to Exceed Median RTS IoU` = rts_area_exceed_median,
         `RTS Area Threshold Where Slope <1e-05` = rts_threshold,
         `RTS Area to Exceed 0.5` = rts_area_exceed_0.5)

# write.csv(min_rts_area,
#           './tables/rts_area_thresholds.csv',
#           row.names = FALSE)

knitr::kable(min_rts_area)
```

```{r, fig.width = 6.5, fig.height = 4}
ggplot(polys, 
       aes(x = rts_area, 
           y = rts_iou)) +
  geom_point(aes(color = pq_ci, shape = yg), size = 1) +
  scale_color_manual(name = 'Prediction\nQuality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, ymin = lwr, ymax = upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci, 
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')'),
                     minor_breaks = seq(0, 125000, by = 5000)) +
  scale_y_continuous(name = 'RTS IoU',
                     limits = c(-0.1, 1),
                     expand = expansion(mult = 0),
                     minor_breaks = seq(-0.1, 1, by = 0.05)) +
  scale_shape_manual(name = 'Region',
                     labels = c('Other', 'Yamal/\nGydan'),
                     values = c(1, 16)) +
  facet_grid(. ~ imagery) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

# ggsave('./figures/area_iou.pdf',
#        height = 4,
#        width = 6.5)
# ggsave('./figures/area_iou.jpg',
#        height = 4,
#        width = 6.5)
```

```{r, fig.width = 12}
ggplot(polys, 
       aes(x = rts_area, 
           y = rts_iou)) +
  geom_point(aes(color = pq_ci_size, shape = yg), size = 1) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  new_scale('color') +
  geom_ribbon(data = iou_ci,
              aes(x = rts_area, 
                  ymin = lwr, 
                  ymax = upr),
              fill = 'gray50',
              alpha = 0.2,
              inherit.aes = FALSE) +
  geom_line(data = iou_ci,
            aes(x = rts_area, y = prediction, color = imagery),
            inherit.aes = FALSE) +
  geom_vline(data = size_thresholds,
             aes(xintercept = rts_threshold, color = imagery),
            linetype = 'dashed') +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  scale_x_continuous(name = expression('RTS Area (m'^2*')')) +
  scale_y_continuous(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  # coord_cartesian(ylim = c(0, 1)) +
  facet_grid(. ~ imagery)
```

```{r}
knitr::kable(polys %>%
               as_tibble() %>%
               count(imagery, pq_ci) %>%
               pivot_wider(names_from = pq_ci, values_from = n))
```

Is performance class the same across imagery sources for most RTS features?

```{r}
polys <- polys %>%
  mutate(
    pq_ci_offset = case_when(
      imagery == 'WorldView' ~ as.numeric(pq_ci) - 0.2,
      imagery == 'PlanetScope' ~ as.numeric(pq_ci),
      imagery == 'Sentinel-2' ~ as.numeric(pq_ci) + 0.2
      )
    )

# set plotting order
rts_pq <- polys %>%
  as_tibble() %>%
  select(id, imagery, pq_ci) %>%
  mutate(
    pq_ci_high = case_when(pq_ci == 'High' ~ 1,
                           TRUE ~ 0),
    imagery_high = case_when(pq_ci_high == 1 ~ imagery,
                             TRUE ~ NA),
    pq_ci_expected = case_when(pq_ci == 'Expected' ~ 1,
                               TRUE ~ 0),
    imagery_expected = case_when(pq_ci_expected == 1 ~ imagery,
                             TRUE ~ NA),
    pq_ci_low = case_when(pq_ci == 'Low' ~ 1,
                          TRUE ~ 0),
    imagery_low = case_when(pq_ci_low == 1 ~ imagery,
                             TRUE ~ NA)
  ) %>%
  summarise(High = sum(pq_ci_high),
            imagery_high = str_flatten(imagery_high, collapse = ', ', na.rm = TRUE),
            Expected = sum(pq_ci_expected),
            imagery_expected = str_flatten(imagery_expected, collapse = ', ', na.rm = TRUE),
            Low = sum(pq_ci_low),
            imagery_low = str_flatten(imagery_low, collapse = ', ', na.rm = TRUE),
            .by = id) %>%
  mutate(max_n = max(c(High, Expected, Low)),
         .by = id) %>%
  mutate(
    plotting_order = case_when(
      High == 2 & Low == 1 & imagery_low == 'WorldView' ~ 1,
      High == 2 & Low == 1 & imagery_low == 'PlanetScope' ~ 2,
      High == 2 & Low == 1 & imagery_low == 'Sentinel-2' ~ 3,
      High == 3 ~ 4,
      High == 2 & Expected == 1 & imagery_expected == 'WorldView' ~ 5,
      High == 2 & Expected == 1 & imagery_expected == 'PlanetScope' ~ 6,
      High == 2 & Expected == 1 & imagery_expected == 'Sentinel-2' ~ 7,
      Expected == 2 & High == 1 & imagery_high == 'WorldView' ~ 8,
      Expected == 2 & High == 1 & imagery_high == 'PlanetScope' ~ 9,
      Expected == 2 & High == 1 & imagery_high == 'Sentinel-2' ~ 10,
      Expected == 3 ~ 11,
      Expected == 2 & Low == 1 & imagery_low == 'WorldView' ~ 12,
      Expected == 2 & Low == 1 & imagery_low == 'PlanetScope' ~ 13,
      Expected == 2 & Low == 1 & imagery_low == 'Sentinel-2' ~ 14,
      Low == 2 & Expected == 1 & imagery_expected == 'WorldView' ~ 15,
      Low == 2 & Expected == 1 & imagery_expected == 'PlanetScope' ~ 16,
      Low == 2 & Expected == 1 & imagery_expected == 'Sentinel-2' ~ 17,
      Low == 3 ~ 18,
      Low == 2 & High == 1 & imagery_high == 'WorldView' ~ 19,
      Low == 2 & High == 1 & imagery_high == 'PlanetScope' ~ 20,
      Low == 2 & High == 1 & imagery_high == 'Sentinel-2' ~ 21,
      max_n == 1 & imagery_low == 'WorldView' ~ 22,
      max_n == 1 & imagery_low == 'PlanetScope' ~ 23,
      max_n == 1 & imagery_low == 'Sentinel-2' ~ 24
    )
  ) %>%
  arrange(plotting_order, id) %>%
  mutate(id = factor(id,
                     levels = c(unique(.$id))))

polys <- polys %>%
  mutate(id = factor(id,
                     levels = c(unique(rts_pq$id))))
```

```{r, fig.height = 1.75, fig.width = 6.5}
ggplot(polys, 
       aes(x = id, y = pq_ci_offset, color = imagery)) +
  geom_point() +
  scale_y_reverse(name = 'Prediction Quality',
                  breaks = c(1, 2, 3),
                  labels = pq_labels) +
  scale_x_discrete(name = 'RTS Features') +
  scale_color_manual(name = 'Imagery',
                     values = imagery_colors) +
  # facet_grid(name_long ~ ., scales = 'free_y') +
  theme(axis.text.x = element_blank(),
        panel.grid.major.y = element_blank()) +
  coord_fixed(ratio = 7)

# ggsave('./figures/prediction_quality_by_imagery.pdf',
#        height = 1.75,
#        width = 6.5)
# ggsave('./figures/prediction_quality_by_imagery.jpg',
#        height = 1.75,
#        width = 6.5)
```

### Zonal Statistics

```{r}
input_data <- input_data %>%
  left_join(polys %>%
              as_tibble() %>%
              select(id, imagery, yg, rts_area, rts_shape, rts_iou, mean_iou, 
                     mean_iou_v2, pq_ci, pq_ci_size),
            by = c('imagery', 'id')) %>%
  left_join(masks_df, by = c('imagery', 'id', 'x', 'y'))
```

```{r}
zonal_stats <- input_data %>%
  filter(mask == 1) %>%
  summarise(across(c(prediction, r:sr), mean, .names = "{.col}_mean"),
            across(r:sr, sd, .names = "{.col}_sd"),
            .by = c(imagery, id, yg, rts_class, rts_area, rts_shape, rts_iou, 
                    mean_iou, mean_iou_v2, pq_ci, pq_ci_size)) %>%
  pivot_wider(names_from = 'rts_class', 
              values_from = c(prediction_mean:sr_sd)) %>%
  mutate(r_mean_delta = (r_mean_rts - r_mean_bg),
         b_mean_delta = (b_mean_rts - b_mean_bg),
         g_mean_delta = (g_mean_rts - g_mean_bg),
         lum_mean_delta = (lum_mean_rts - lum_mean_bg),
         nir_mean_delta = (nir_mean_rts - nir_mean_bg),
         ndvi_mean_delta = (ndvi_mean_rts - ndvi_mean_bg),
         ndwi_mean_delta = (ndwi_mean_rts - ndwi_mean_bg),
         elev_mean_delta = (elev_mean_rts - elev_mean_bg),
         sr_mean_delta = (sr_mean_rts - sr_mean_bg),
         r_sd_delta = (r_sd_rts - r_sd_bg),
         b_sd_delta = (b_sd_rts - b_sd_bg),
         g_sd_delta = (g_sd_rts - g_sd_bg),
         lum_sd_delta = (lum_sd_rts - lum_sd_bg),
         nir_sd_delta = (nir_sd_rts - nir_sd_bg),
         ndvi_sd_delta = (ndvi_sd_rts - ndvi_sd_bg),
         ndwi_sd_delta = (ndwi_sd_rts - ndwi_sd_bg),
         elev_sd_delta = (elev_sd_rts - elev_sd_bg),
         sr_sd_delta = (sr_sd_rts - sr_sd_bg)) %>%
  pivot_longer(r_mean_bg:sr_sd_delta, 
               names_to = 'variable', 
               values_to = 'value') %>%
  separate(variable, 
           into = c('variable', 'metric', 'rts_class'), 
           sep = '_') %>%
  mutate(rts_class = factor(case_when(rts_class == 'rts' ~ 'RTS',
                                      rts_class == 'bg' ~ 'Background',
                                      rts_class == 'delta' ~ 'Delta'),
                            levels = c('RTS', 'Delta', 'Background'))) %>%
  pivot_wider(names_from = c('variable', 'metric'),
              values_from = 'value')
```

```{r}
lm_output <- zonal_stats %>%
  select(imagery:sr_sd, pq_ci, pq_ci_size) %>%
  pivot_longer(r_mean:sr_sd, names_to = 'variable', values_to = 'value') %>%
  group_by(rts_class, imagery, variable) %>%
  nest() %>% 
  mutate(models_pq = map(data, 
                         possibly(lm_pq, otherwise = NA)),
         summary_pq = map(models_pq, 
                          possibly(lm_summary, otherwise = NA)),
         contrasts_pq = map(models_pq, 
                            possibly(lm_contrasts_pq, 
                                     otherwise = NA)))
```

```{r}
zonal_stats_contrasts <- lm_output %>%
  select(imagery, rts_class, variable, contrasts_pq) %>%
  unnest(cols = c(contrasts_pq)) %>%
  ungroup() %>%
  filter(p_value <= 0.1) %>%
  separate_wider_delim(contrast, 
                       delim = ' - ', 
                       names = c('x_min', 'x_max'), 
                       cols_remove = FALSE) %>%
  mutate(x_min = as.numeric(factor(x_min,
                                   levels = pq_labels)) + 0.05,
         x_max = as.numeric(factor(x_max,
                                   levels = pq_labels)) - 0.05)
```

```{r}
# calculate figure y-limits by hand
# (1.5*IQR is the upper and lower whisker limit; 1.05 is the default axis expansion by ggplot)
zonal_stats_limits <- zonal_stats %>%
  select(imagery:sr_sd, pq_ci) %>%
  pivot_longer(r_mean:sr_sd,  names_to = 'variable', values_to = 'value') %>%
  summarise(
    # lwr = min(trim_outliers(value), na.rm = TRUE), # use this if removing outliers from plots
    # upr = max(trim_outliers(value), na.rm = TRUE),
    lwr = min(value, na.rm = TRUE),
    upr = max(value, na.rm = TRUE),
    .by = c(imagery, pq_ci, rts_class, variable)
    ) %>%
  mutate(lim_lwr = upr - (upr - lwr)*1.05,
         lim_upr = lwr + (upr - lwr)*1.05) %>%
  summarise(lwr = min(lim_lwr),
            upr = max(lim_upr),
            .by = c(variable, rts_class))
```

```{r}
zonal_stats_contrasts <- zonal_stats_contrasts %>%
  left_join(zonal_stats_limits, by = c('variable', 'rts_class')) %>%
  mutate(n = n(),
         y = case_when(
           n >= 2 & contrast == 'High - Low' ~ lwr + (upr - lwr)*1.2,
           TRUE ~ lwr + (upr - lwr)*1.05
           ),
         upr = case_when(
           n >= 2 & contrast == 'High - Low' ~ lwr + (upr - lwr)*1.3,
           TRUE ~ lwr + (upr - lwr)*1.15),
         .by = c(imagery, rts_class, variable)
         )

# add new upr limits back to limits tibble
zonal_stats_limits <- zonal_stats_limits %>%
  left_join(zonal_stats_contrasts %>%
              select(imagery, rts_class, variable, upr) %>%
              group_by(rts_class, variable) %>%
              summarise(new_upr = max(upr)),
            by = c('rts_class', 'variable')) %>%
  mutate(upr = case_when(!is.na(new_upr) ~ new_upr,
                         TRUE ~ upr)) %>%
  select(-new_upr)

```


These plots summarize the input data values (mean or standard deviation) in RTS cells, background cells, and the normalized difference between the two (`Delta = RTS - Background`). Most of the input layer names should be self explanatory, but for the others:

lum = [luminance](https://stackoverflow.com/questions/596216/formula-to-determine-perceived-brightness-of-rgb-color) = `0.299*r + 0.587*g + 0.114*b` 

sr = shaded relief

```{r, include = FALSE}
variables <- colnames(zonal_stats %>%
                        ungroup() %>%
                        select(r_mean:sr_sd))
zonal_stats_figs <- map(
  variables,
  ~ plot_zonal_stats(
    x_var = 'pq_ci',
    y_var = .x, 
    contrasts = zonal_stats_contrasts,
    limits = zonal_stats_limits)
)
names(zonal_stats_figs) <- variables
```

A few takeaway points:

- Brighter RTS against a darker background are predicted better in the PlanetScope model. Doesn't seem to be related to seasonality.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['r_mean']]
zonal_stats_figs[['g_mean']]
zonal_stats_figs[['b_mean']]
zonal_stats_figs[['lum_mean']]

# ggsave('./figures/zonal_stats_red.pdf',
#        zonal_stats_figs[['r_mean']],
#        height = 5.5,
#        width = 6.5)
# ggsave('./figures/zonal_stats_red.jpg',
#        zonal_stats_figs[['r_mean']],
#        height = 5.5,
#        width = 6.5)
# 
# ggsave('./figures/zonal_stats_green.pdf',
#        zonal_stats_figs[['g_mean']],
#        height = 5.5,
#        width = 6.5)
# ggsave('./figures/zonal_stats_green.jpg',
#        zonal_stats_figs[['g_mean']],
#        height = 5.5,
#        width = 6.5)
# 
# ggsave('./figures/zonal_stats_blue.pdf',
#        zonal_stats_figs[['b_mean']],
#        height = 5.5,
#        width = 6.5)
# ggsave('./figures/zonal_stats_blue.jpg',
#        zonal_stats_figs[['b_mean']],
#        height = 5.5,
#        width = 6.5)
# 
# ggsave('./figures/zonal_stats_lum.pdf',
#        zonal_stats_figs[['lum_mean']],
#        height = 5.5,
#        width = 6.5)
# ggsave('./figures/zonal_stats_lum.jpg',
#        zonal_stats_figs[['lum_mean']],
#        height = 5.5,
#        width = 6.5)
```

-   Poorly predicted RTS in the PlanetScope and Sentinel models had higher NIR values within features. Both plants and soil reflect a lot of NIR... so what this means is a bit unclear.

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['nir_mean']]

# ggsave('./figures/zonal_stats_nir.pdf',
#        zonal_stats_figs[['nir_mean']],
#        height = 5.5,
#        width = 6.5)
# ggsave('./figures/zonal_stats_nir.jpg',
#        zonal_stats_figs[['nir_mean']],
#        height = 5.5,
#        width = 6.5)
```

I didn't find much interesting about the rest of these figures, but they are included  here for completeness:

```{r, fig.width = 7, fig.height = 6}
zonal_stats_figs[['ndvi_mean']]
zonal_stats_figs[['ndwi_mean']]
zonal_stats_figs[['elev_mean']]
zonal_stats_figs[['sr_mean']]
zonal_stats_figs[['r_sd']]
zonal_stats_figs[['g_sd']]
zonal_stats_figs[['b_sd']]
zonal_stats_figs[['lum_sd']]
zonal_stats_figs[['nir_sd']]
zonal_stats_figs[['ndvi_sd']]
zonal_stats_figs[['ndwi_sd']]
zonal_stats_figs[['elev_sd']]
zonal_stats_figs[['sr_sd']]
```

### Prediction Probability

```{r}
rts_labeller <- as_labeller(c(WorldView = 'WorldView', PlanetScope = 'PlanetScope', `Sentinel-2` = '`Sentinel-2`',
                              rts = 'RTS', bg = 'Background'),
                            default = label_parsed)

```

NIR/NDVI

```{r}
ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  # geom_bin_2d(data = input_data %>%
  #               filter(rts_class == 'rts'),
  #             aes(x = ndvi, y = prediction),
  #             inherit.aes = FALSE) +
  # scale_fill_gradient(name = 'Density (RTS)',
  #                     low = '#CCFF99',
  #                     high = '#003300',
  #                     trans = "log10",
  #                     limits = c(1, 1000000),
  #                     guide = guide_legend(order = 1)) +
  # new_scale('fill') +
  # geom_bin_2d(data = input_data %>%
  #               filter(rts_class == 'bg'),
  #             aes(x = ndvi, y = prediction),
  #             inherit.aes = FALSE) +
  # scale_fill_gradient(name = 'Density (Background)',
  #                     low = '#CCCCCC',
  #                     high = '#000000',
  #                     trans = "log10",
  #                     limits = c(1, 1000000),
  #                     guide = guide_legend(order = 2)) +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

```{r}
ggplot(input_data %>%
         filter(mask == 1 & imagery == 'WorldView'), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('WorldView')

ggplot(input_data %>%
         filter(mask == 1 & imagery == 'PlanetScope'), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('PlanetScope')

ggplot(input_data %>%
         filter(mask == 1 & imagery == 'Sentinel-2'), 
       aes(x = nir, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NIR') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Sentinel-2')

ggplot(input_data %>%
         filter(mask == 1 & imagery == 'WorldView'), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('WorldView')

ggplot(input_data %>%
         filter(mask == 1 & imagery == 'PlanetScope'), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('PlanetScope')

ggplot(input_data %>%
         filter(mask == 1 & imagery == 'Sentinel-2'), 
       aes(x = ndvi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDVI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ pq_ci) +
  ggtitle('Sentinel-2')
```

NDWI

```{r}
ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = ndwi, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'NDWI') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

Elevation

```{r}
ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = elev, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Relative Elevation') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

Others

```{r}
ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = r, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Red') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = g, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Green') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = b, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Blue') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)

ggplot(input_data %>%
         filter(mask == 1), 
       aes(x = sr, y = prediction)) +
  geom_bin_2d() +
  scale_fill_gradient(name = 'Count',
                      low = '#CCCCCC',
                      high = '#000000',
                      trans = "log10",
                      limits = c(1, 1000000)) +
  scale_x_continuous(name = 'Shaded Relief') +
  scale_y_continuous(name = 'Prediction') +
  geom_hline(yintercept = 0.5, linetype = 'dashed') +
  facet_grid(rts_class ~ imagery,
             labeller = rts_labeller)
```

### PCA Analysis

```{r}
zonal_stats_class <- zonal_stats %>%
  filter(rts_class %in% c('RTS', 'Background')) %>%
  mutate(rts_class = factor(rts_class,
                            levels = c('RTS', 'Background')))

zonal_stats_pca <- prcomp(zonal_stats_class %>%
                            ungroup() %>%
                            select(r_mean:b_mean, nir_mean:sr_mean,
                                   r_sd:b_sd, nir_sd:sr_sd),
                          center = TRUE,
                          scale = TRUE)

zonal_stats_class <- zonal_stats_class %>%
  cbind(zonal_stats_pca[['x']])
```

PCA - Imagery color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~imagery,
        colors = imagery_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

PCA - Prediction quality color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

WorldView

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'WorldView'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

PlanetScope

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'PlanetScope'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Sentinel-2

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Sentinel-2'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~pq_ci,
        colors = pq_colors,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'pq_ci',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_manual(name = 'Prediction Quality', 
                     labels = pq_labels,
                     values = pq_colors) +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'pq_ci',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_manual(name = 'Prediction Quality', 
                     labels = pq_labels,
                     values = pq_colors) +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'pq_ci',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_manual(name = 'Prediction Quality', 
                     labels = pq_labels,
                     values = pq_colors) +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

PCA - RTS probability color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

WorldView

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'WorldView'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

PlanetScope

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'PlanetScope'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

Sentinel-2

```{r}
plot_ly(zonal_stats_class %>%
          filter(imagery == 'Sentinel-2'), 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~prediction_mean_rts,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'prediction_mean_rts',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'Mean RTS Probability') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'prediction_mean_rts',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'Mean RTS Probability') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'prediction_mean_rts',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'Mean RTS Probability') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

PCA - IoU color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~rts_iou,
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'rts_iou',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS IoU') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'rts_iou',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS IoU') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'rts_iou',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS IoU') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

PCA - RTS area color scheme

```{r}
plot_ly(zonal_stats_class, 
        x = ~PC1, y = ~PC2, z = ~PC3, 
        color = ~log10(rts_area),
        symbol = ~rts_class,
        symbols = c('circle', 'circle-open'),
        size = 1) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))
```

```{r}
autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 2,
         color = 'rts_area',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS Area',
                      trans = 'log10') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 1,
         y = 3,
         color = 'rts_area',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS Area',
                      trans = 'log10') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))

autoplot(zonal_stats_pca, 
         data = zonal_stats_class, 
         x = 2,
         y = 3,
         color = 'rts_area',
         shape = 'rts_class', 
         loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 4,
         loadings.label.colour = 'black') +
  scale_color_viridis(name = 'RTS Area',
                      trans = 'log10') +
  scale_shape_manual(name = 'RTS Class',
                     labels = c('RTS', 'Background', 'Delta'),
                     values = c(16, 1, 2))
```

### Prediction Quality Random Forest

```{r}
pq_rf <- randomForest::randomForest(pq_ci ~ .,
                      data = zonal_stats %>%
                        as_tibble() %>%
                        select(-c(id, rts_iou, mean_iou, mean_iou_v2, 
                                  pq_ci_size, prediction_mean_rts,
                                  prediction_mean_bg)) %>%
                        mutate(rts_class = case_when(
                          rts_class == 'RTS' ~ 'rts',
                          rts_class == 'Delta' ~ 'delta',
                          rts_class == 'Background' ~ 'bg')
                        ) %>%
                        pivot_wider(names_from = rts_class,
                                    values_from = r_mean:sr_sd))
```

```{r}
print(pq_rf)
```

No, we can't predict the prediction quality very well based on the input data, feature size, shape, region, etc.


## RTS Morphology

```{r}
ggplot(polys, 
       aes(x = rts_shape, y = rts_area, color = pq_ci, shape = yg)) +
  geom_point() +
  scale_x_continuous(name = 'RTS Shape (Polsby-Popper)') +
  scale_y_log10(name = expression('RTS Area (m'^2 * ')'),
                minor_breaks = c(seq(100, 900, by = 100),
                           seq(1000, 9000, by = 1000),
                           seq(10000, 90000, by = 10000),
                           seq(100000, 200000, by = 100000))) +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16)) +
  facet_grid(. ~ imagery) +
  theme(axis.text.y = element_text(angle = 90))
```

```{r}
rts_shape_area_iou <- ggplot(polys, 
       aes(x = rts_shape, y = rts_area, color = rts_iou, shape = yg)) +
  geom_point() +
  scale_x_continuous(name = 'RTS Shape (Polsby-Popper)') +
  scale_y_log10(name = expression('RTS Area (m'^2 * ')'),
                labels = scales::label_number(big.mark = ''),
                minor_breaks = c(seq(100, 900, by = 100),
                           seq(1000, 9000, by = 1000),
                           seq(10000, 90000, by = 10000),
                           seq(100000, 200000, by = 100000))) +
  scale_color_viridis(name = 'RTS IoU') +
  scale_shape_manual(name = 'Region',
                     values = c(1, 16),
                     labels = c('Other', 'Yamal/\nGydan')) +
  facet_grid(. ~ imagery) +
  theme(axis.text.y = element_text(angle = 90, hjust = 0.5))
rts_shape_area_iou

# ggsave('./figures/rts_shape_area.pdf',
#        rts_shape_area_iou,
#        height = 4,
#        width = 6.5)
# ggsave('./figures/rts_shape_area.jpg',
#        rts_shape_area_iou,
#        height = 4,
#        width = 6.5)
```

```{r}
polys <- polys %>%
  mutate(rts_area_log10 = log10(rts_area))

# WorldView models
maxar_lm_smallest <- lm(rts_iou ~ 1,
                        data = polys %>%
                          filter(imagery == 'WorldView'))
maxar_lm_area <- lm(rts_iou ~ rts_area_log10,
                        data = polys %>%
                          filter(imagery == 'WorldView'))
maxar_lm_area_shape <- lm(rts_iou ~ rts_area_log10 + rts_shape,
                          data = polys %>%
                            filter(imagery == 'WorldView'))
maxar_lm_interaction <- lm(rts_iou ~ rts_area_log10*rts_shape,
                           data = polys %>%
                             filter(imagery == 'WorldView'))

# PlanetScope models
planet_lm_smallest <- lm(rts_iou ~ 1,
                        data = polys %>%
                          filter(imagery == 'PlanetScope'))
planet_lm_area <- lm(rts_iou ~ rts_area_log10,
                        data = polys %>%
                          filter(imagery == 'PlanetScope'))
planet_lm_area_shape <- lm(rts_iou ~ rts_area_log10 + rts_shape,
                          data = polys %>%
                            filter(imagery == 'PlanetScope'))
planet_lm_interaction <- lm(rts_iou ~ rts_area_log10*rts_shape,
                           data = polys %>%
                             filter(imagery == 'PlanetScope'))

# Sentinel models
sentinel_lm_smallest <- lm(rts_iou ~ 1,
                        data = polys %>%
                          filter(imagery == 'Sentinel-2'))
sentinel_lm_area <- lm(rts_iou ~ rts_area_log10,
                        data = polys %>%
                          filter(imagery == 'Sentinel-2'))
sentinel_lm_area_shape <- lm(rts_iou ~ rts_area_log10 + rts_shape,
                          data = polys %>%
                            filter(imagery == 'Sentinel-2'))
sentinel_lm_interaction <- lm(rts_iou ~ rts_area_log10*rts_shape,
                           data = polys %>%
                             filter(imagery == 'Sentinel-2'))

iou_lm_output <- tibble(Imagery = 'WorldView',
                        Model = 'IoU ~ 1',
                        AIC = AIC(maxar_lm_smallest),
                        r2 = summary(maxar_lm_smallest)$r.squared) %>%
  bind_rows(tibble(Imagery = 'WorldView',
                   Model = 'IoU ~ Area',
                   AIC = AIC(maxar_lm_area),
                   r2 = summary(maxar_lm_area)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'WorldView',
                   Model = 'IoU ~ Area + Shape',
                   AIC = AIC(maxar_lm_area_shape),
                   r2 = summary(maxar_lm_area_shape)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'WorldView',
                   Model = 'IoU ~ Area*Shape',
                   AIC = AIC(maxar_lm_interaction),
                   r2 = summary(maxar_lm_interaction)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'PlanetScope',
                   Model = 'IoU ~ 1',
                   AIC = AIC(planet_lm_smallest),
                   r2 = summary(planet_lm_smallest)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'PlanetScope',
                   Model = 'IoU ~ Area',
                   AIC = AIC(planet_lm_area),
                   r2 = summary(planet_lm_area)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'PlanetScope',
                   Model = 'IoU ~ Area + Shape',
                   AIC = AIC(planet_lm_area_shape),
                   r2 = summary(planet_lm_area_shape)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'PlanetScope',
                   Model = 'IoU ~ Area*Shape',
                   AIC = AIC(planet_lm_interaction),
                   r2 = summary(planet_lm_interaction)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'Sentinel-2',
                   Model = 'IoU ~ 1',
                   AIC = AIC(sentinel_lm_smallest),
                   r2 = summary(sentinel_lm_smallest)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'Sentinel-2',
                   Model = 'IoU ~ Area',
                   AIC = AIC(sentinel_lm_area),
                   r2 = summary(sentinel_lm_area)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'Sentinel-2',
                   Model = 'IoU ~ Area + Shape',
                   AIC = AIC(sentinel_lm_area_shape),
                   r2 = summary(sentinel_lm_area_shape)$r.squared)) %>%
  bind_rows(tibble(Imagery = 'Sentinel-2',
                   Model = 'IoU ~ Area*Shape',
                   AIC = AIC(sentinel_lm_interaction),
                   r2 = summary(sentinel_lm_interaction)$r.squared)) %>%
  mutate(across(r2:AIC, ~ round(.x, 3)))
knitr::kable(iou_lm_output)

# write.csv(iou_lm_output,
#           './tables/iou_lm_summary.csv',
#           row.names = FALSE)
```


## Regions

```{r}
ggplot() +
  geom_sf(data = world_north, fill = 'transparent') +
  geom_sf(data = polys,
          aes(geometry = rts_geometry, color = rts_area),
          linewidth = 1,
          inherit.aes = FALSE) +
  scale_color_viridis(trans = 'log')

ggplot(polys, aes(x = Long, y = rts_area)) +
  geom_point(aes(color = region)) +
  scale_color_viridis(name = 'Region',
                      discrete = TRUE)
```

### Banks Island

```{r}
knitr::kable(polys%>%
               as_tibble() %>%
               summarise(rts_area_median = median(rts_area),
                         rts_iou = round(mean(rts_iou), 2),
                         .by = c('imagery', 'banks')))
knitr::kable(polys%>%
               as_tibble() %>%
               summarise(rts_area_median = median(rts_area),
                         rts_iou = round(mean(rts_iou), 2),
                         .by = c('imagery', 'yg')))
```

```{r}
newdata <- tibble(rts_area = c(1214.551, 9093.981),
                  region = c('yg', 'banks'))

regions_pred <- nlsBootPredict(
  maxar_iou_boot, 
  newdata = newdata, 
  interval = 'prediction'
) %>%
  as_tibble() %>%
  mutate(imagery = 'WorldView') %>%
  bind_cols(newdata) %>%
  bind_rows(
    nlsBootPredict(
      planet_iou_boot, 
      newdata = tibble(rts_area = c(1214.551, 9093.981)), 
      interval = 'prediction'
    ) %>%
      as_tibble() %>%
  mutate(imagery = 'PlanetScope') %>%
  bind_cols(newdata)
  ) %>%
  bind_rows(
    nlsBootPredict(
      sentinel_iou_boot, 
      newdata = tibble(rts_area = c(1214.551, 9093.981)), 
      interval = 'prediction'
    ) %>%
      as_tibble() %>%
  mutate(imagery = 'Sentinel-2') %>%
  bind_cols(newdata)
  ) %>%
  select(imagery, region, rts_area, Median, `2.5%`, `97.5%`)

knitr::kable(regions_pred)
```

### YG Region

The YG Region has smaller RTS features, which is probably responsible for the poorer IoU scores in the region.

```{r}
knitr::kable(polys%>%
               as_tibble() %>%
               summarise(rts_iou = round(mean(rts_iou), 2),
                         .by = c('imagery', 'yg')))
```

```{r}
iou_ci %>%
  filter(abs(rts_area - 1215) == min(abs(rts_area - 1215)),
         .by = imagery)
```

The Yamal-Gydan Peninsula appears to be both drier and have smaller RTS features, so these two variables are hard to disentangle.

```{r}
zonal_stats_class %>%
  group_by(imagery, id, yg) %>%
  summarise(ndwi_mean = mean(ndwi_mean),
            rts_area = first(rts_area),
            region = first(yg)) %>%
ggplot(aes(x = ndwi_mean, y = rts_area, color = yg)) +
  geom_point()
```

All models are tripped up by the Yamal/Gydan Region.

```{r, fig.height = 4, fig.width = 6.5}
rts_pq_hist <- ggplot(polys,
       aes(x = yg, fill = pq_ci)) +
  geom_bar(position = 'fill') +
  scale_x_discrete(name = 'Region') +
  scale_y_continuous(labels = scales::percent,
                     minor_breaks = seq(0, 1, by = 0.05)) +
  scale_fill_manual(name = 'Prediction\nQuality',
                    values = pq_colors) +
  facet_grid(. ~ imagery) +
  theme(axis.title.y = element_blank())
rts_pq_hist

# ggsave('./figures/rts_pq_hist.pdf',
#        rts_pq_hist,
#        height = 4,
#        width = 6.5)
# ggsave('./figures/rts_pq_hist.jpg',
#        rts_pq_hist,
#        height = 4,
#        width = 6.5)
```


## Case Studies

There are two really large RTS that were poorly predicted in at least one of the PlanetScope and Sentinel models:

-   May be that the RTS being so big is causing issues with the model (missing edges in the imagery)
-   I'm not sure if this is impacting the prediction, but the tile for Sentinel is pretty different and includes a bunch of open water that's not in either of the other images.
-   Both the PlanetScope and Sentinel images are really blurry relative to the WorldView in this area, making it visually impossible to delineate the RTS outside of the WorldView data.
-   The RTS features seem to be brighter relative to the background in the poorly predicted ones, which is backwards from the conclusions of the zonal stats analysis.

```{r}
rts_id <- polys %>%
  as_tibble() %>%
  filter(rts_area > 100000 & pq_ci == 'Low') %>%
  select(id) %>%
  mutate(id = as.character(id)) %>%
  pull(id) %>%
  unique()

ggplot(data = polys %>%
         filter(id == rts_id[1])) +
  geom_raster(data = input_data %>%
                filter(id == rts_id[1]),
              aes(x = x, y = y, fill = color_hex),
              inherit.aes = FALSE) +
  scale_fill_manual(breaks = levels(input_data$color_hex),
                    values = levels(input_data$color_hex),
                    guide = 'none') +
  geom_sf(aes(geometry = val_geometry,
              color = 'Validation'),
          fill = 'transparent',
          linewidth = 0.5) +
  scale_color_manual(values = c('gray90')) +
new_scale('color') +
  geom_sf(aes(geometry = pred_geometry,
              color = pq_ci),
          fill = 'transparent',
          linewidth = 0.5) +
  scale_color_manual(name = '',
                     values = pq_colors[2:3]) +
  facet_grid(imagery ~ .) +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggplot(data = polys %>%
         filter(id == rts_id[2])) +
  geom_raster(data = input_data %>%
                filter(id == rts_id[2]),
              aes(x = x, y = y, fill = color_hex),
              inherit.aes = FALSE) +
  scale_fill_manual(breaks = levels(input_data$color_hex),
                    values = levels(input_data$color_hex),
                    guide = 'none') +
  geom_sf(aes(geometry = val_geometry,
              color = 'Validation'),
          fill = 'transparent',
          linewidth = 0.5) +
  scale_color_manual(values = c('gray90')) +
new_scale('color') +
  geom_sf(aes(geometry = pred_geometry,
              color = pq_ci),
          fill = 'transparent',
          linewidth = 0.5) +
  scale_color_manual(name = '',
                     values = pq_colors) +
  facet_grid(imagery ~ .) +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

ggplot(zonal_stats %>%
         filter(rts_area > 35000),
       aes(x = imagery, y = lum_mean, color = pq_ci)) +
  geom_point() +
  scale_color_manual(name = 'Prediction Quality',
                     values = pq_colors) +
  # scale_shape_manual(values = c(16, 2, 1)) +
  facet_grid(rts_class ~ .)
```

In the RTS features which had different prediction qualities across all three models, the main patterns are:

-   PlanetScope completely missed the feature, WorldView did well, Sentinel did ok (2)
-   The rest all had a prediction in each model, and each one was different in terms of which models had which prediction quality (3)


```{r}
polys <- polys %>%
  as_tibble() %>%
  mutate(pq_n_unique = length(unique(pq_ci)),
         .by = id)

rts_ids <- polys %>%
  filter(pq_n_unique == 3) %>%
  mutate(id = as.character(id)) %>%
  pull(id) %>%
  unique()
```

```{r}
for (rts_id in rts_ids) {
  print(
    ggplot(data = polys %>%
             filter(id == rts_id)) +
      geom_raster(data = input_data %>%
                    filter(id == rts_id),
                  aes(x = x, y = y, fill = color_hex),
                  inherit.aes = FALSE) +
      scale_fill_manual(breaks = levels(input_data$color_hex),
                        values = levels(input_data$color_hex),
                        guide = 'none') +
      geom_sf(aes(geometry = val_geometry,
                  color = 'Validation'),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(values = c('gray90')) +
      new_scale('color') +
      geom_sf(aes(geometry = pred_geometry,
                  color = pq_ci),
              fill = 'transparent',
              linewidth = 0.5) +
      scale_color_manual(name = '',
                         values = pq_colors) +
      facet_grid(imagery ~ .) +
      theme(axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank())
  )
  
}
```

Whether or not all the models were able to predict a feature well did not correlate with size or shape:

```{r}
ggplot(polys,
       aes(x = rts_area, y = rts_shape, color = factor(pq_n_unique))) +
  geom_point() +
  scale_x_log10(name = expression('RTS Area (m'^2 * ')')) +
  scale_y_continuous(name = 'RTS Shape') +
  scale_color_viridis(name = 'Number of Unique\nPrediction Quality\nDesignations Across\nImagery Types',
                      discrete = TRUE)
```

```{r}
ggplot(polys, aes(x = rts_area, y = pq_n_unique)) +
  geom_point() +
  scale_x_log10()

ggplot(polys, aes(x = rts_shape, y = pq_n_unique)) +
  geom_point()
```


## RTS Subset Maps

```{r}
id_subset <- c(
    "00000000000000000072",
    "0000000000000000005d",
    "00000000000000000046",
    "00000000000000000032",
    "00000000000000000023",
    "00000000000000000006",
    "00000000000000000010",
    "00000000000000000012",
    "00000000000000000016"
  )

# map_dimensions <- input_data %>%
#   filter(id %in% id_subset) %>%
#   summarise(x_spread = max(x) - min(x),
#             y_spread = max(y) - min(y),
#             .by = c('id')) %>%
#   summarise(x_spread_max = max(x_spread),
#             y_spread_max = max(y_spread))

map_dimensions <- polys %>%
  filter(id %in% id_subset) %>%
  st_as_sf(crs = 3413) %>%
  bind_cols(map_dfr(.$rts_geometry, 
               ~ st_bbox(.x))) %>%
  as_tibble() %>%
  mutate(x_spread = (xmax - xmin)*1.25,
         y_spread = (ymax - ymin)*1.25) %>%
  summarise(x_spread_max = max(x_spread),
            y_spread_max = max(y_spread))

rts_maps_subset <- map(
  id_subset,
  ~ plot_prediction_2(.x, imagery_labels, map_dimensions)
)
```

```{r, fig.width = 6.5, fig.height = 9}
rts_highlights_plot <- (
  rts_maps_subset[[1]] +
    facet_grid('Good Prediction' ~ imagery)
) / (
  rts_maps_subset[[2]] +
    facet_grid('Good Prediction' ~ .)
) / (
  rts_maps_subset[[3]] +
    facet_grid('Bright RTS' ~ .)
) / (
  rts_maps_subset[[4]] +
    facet_grid('Imagery Matters' ~ .)
) / (
  rts_maps_subset[[5]] +
    facet_grid('Imagery Matters' ~ .)
) / (
  rts_maps_subset[[6]] +
    facet_grid('Green RTS' ~ .)
) / (
  rts_maps_subset[[7]] +
    facet_grid('Small RTS' ~ .)
) / (
  rts_maps_subset[[8]] +
    facet_grid('Small RTS' ~ .)
) / (
  rts_maps_subset[[9]] +
    facet_grid('Snow' ~ .)
) +
  plot_layout(guides = 'collect') & theme(legend.position = 'right')

rts_highlights_plot
# ggsave('./figures/rts_highlights.pdf',
#        rts_highlights_plot,
#        height = 9,
#        width = 6.5)
# ggsave('./figures/rts_highlights.jpg',
#        rts_highlights_plot,
#        height = 9,
#        width = 6.5)
```


## Plot Features

Visualize the RTS predictions

```{r fig.width = 12, fig.height = 4.8}
rts_maps <- map(pred_ids,
                 ~ plot_prediction(.x))
walk(rts_maps,
     ~ print(.x))
```

WorldView High Quality Predictions

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'High' & imagery == 'WorldView') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'High' & imagery == 'WorldView') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[1], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

WorldView Low Quality Predictions

-   It missed several that looked really green and others that varied in their visibility in the imagery.
-   It got confused by a snow patch in one.
-   It detected what is probably a larger, older RTS in one.
-   It detected more a feature that had expanded since our delineation.


```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'Low' & imagery == 'WorldView') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'Low' & imagery == 'WorldView') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[3], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

PlanetScope High Quality Predictions

-   Most of these display a bright RTS on a dark background.

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'High' & imagery == 'PlanetScope') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'High' & imagery == 'PlanetScope') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[1], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

PlanetScope Low Quality Predictions

These images seem like they may be blurrier than the well predicted PlanetScope RTS features and/or have less contrast.

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'Low' & imagery == 'PlanetScope') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'Low' & imagery == 'PlanetScope') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[3], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Sentinel High Quality Predictions

-   Many of these are not visible in the imagery, but the model found it anyway. The bright RTS on a dark background pattern seems to hold for many of these, as well.

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'High' & imagery == 'Sentinel-2') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'High' & imagery == 'Sentinel-2') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[1], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

Sentinel Low Quality Predictions

-   Several of these features are very green.

```{r}
# get polygon data
current_data <- polys %>%
  filter(pq_ci == 'Low' & imagery == 'Sentinel-2') %>%
  select(imagery, id, rts_iou, pq_ci, bbox_geometry, val_geometry, 
         pred_geometry)

# prep RGB data
current_rgb <- input_data %>%
  filter(pq_ci == 'Low' & imagery == 'Sentinel-2') %>%
  full_join(current_data %>%
              select(id, imagery, rts_iou),
            by = c('imagery', 'id'))

plots <- map(
  unique(as.character(current_data$id)),
  ~ ggplot(data = current_data %>%
             filter(id == .x)) +
    geom_raster(data = current_rgb %>%
                  filter(id == .x),
                aes(x = x, y = y, fill = color_hex),
                inherit.aes = FALSE) +
    scale_fill_manual(breaks = levels(input_data$color_hex),
                      values = levels(input_data$color_hex),
                      guide = 'none') +
    geom_sf(aes(geometry = bbox_geometry),
            color = 'black',
            fill = 'transparent') +
    geom_sf(aes(geometry = val_geometry,
                color = 'Validation'),
            fill = 'transparent',
            linewidth = 0.5) +
    geom_sf(aes(geometry = pred_geometry,
                color = 'Prediction'),
            fill = 'transparent',
            linewidth = 0.5) +
    scale_color_manual(name = '',
                       values = c(pq_colors[3], 'gray90')) +
    facet_grid(. ~ id) +
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()))
plots
```

